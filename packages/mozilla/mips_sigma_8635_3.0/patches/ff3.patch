diff -ruNa mozilla-orig/build/unix/mozilla-config.in mozilla/build/unix/mozilla-config.in
--- mozilla-orig/build/unix/mozilla-config.in	2004-04-23 04:17:59.000000000 +0800
+++ mozilla/build/unix/mozilla-config.in	2008-07-17 19:52:03.000000000 +0800
@@ -105,7 +105,17 @@
 if test "$echo_cflags" = "yes"; then
     nspr_cflags="%FULL_NSPR_CFLAGS%"
     for n in $echo_components; do
-	component_includes="$component_includes -I%includedir%/$n"
+        case "$n" in
+        js)
+               component_includes="$component_includes -I/usr/include/mozjs"
+            ;;
+        nspr)
+            ;;
+        *)
+               component_includes="$component_includes -I%includedir% \
+                                   -I%includedir%/$n"
+            ;;
+        esac
     done
     echo $component_includes $includes $nspr_cflags
 fi
diff -ruNa mozilla-orig/config/autoconf.mk.in mozilla/config/autoconf.mk.in
--- mozilla-orig/config/autoconf.mk.in	2008-05-06 05:08:14.000000000 +0800
+++ mozilla/config/autoconf.mk.in	2008-07-17 19:21:14.000000000 +0800
@@ -218,6 +218,7 @@
 MOZ_NATIVE_BZ2	= @SYSTEM_BZ2@
 MOZ_NATIVE_JPEG	= @SYSTEM_JPEG@
 MOZ_NATIVE_PNG	= @SYSTEM_PNG@
+APNG		= @APNG@
 MOZ_TREE_CAIRO = @MOZ_TREE_CAIRO@
 
 MOZ_UPDATE_XTERM = @MOZ_UPDATE_XTERM@
diff -ruNa mozilla-orig/config/rules.mk mozilla/config/rules.mk
--- mozilla-orig/config/rules.mk	2008-06-25 07:29:46.000000000 +0800
+++ mozilla/config/rules.mk	2008-07-19 01:57:07.000000000 +0800
@@ -485,8 +485,6 @@
 ifeq ($(OS_ARCH),Linux)
 ifneq (,$(filter mips mipsel,$(OS_TEST)))
 ifeq ($(MODULE),layout)
-OS_CFLAGS += -Wa,-xgot
-OS_CXXFLAGS += -Wa,-xgot
 endif
 endif
 endif
diff -ruNa mozilla-orig/configure mozilla/configure
--- mozilla-orig/configure	2008-06-27 21:41:02.000000000 +0800
+++ mozilla/configure	2008-07-19 01:53:02.000000000 +0800
@@ -5449,6 +5449,7 @@
     WARNINGS_AS_ERRORS='-Werror'
     DSO_CFLAGS=''
     DSO_PIC_CFLAGS='-fPIC'
+    ASFLAGS="$ASFLAGS -fPIC"
     _MOZ_RTTI_FLAGS_ON=${_COMPILER_PREFIX}-frtti
     _MOZ_RTTI_FLAGS_OFF=${_COMPILER_PREFIX}-fno-rtti
     _MOZ_EXCEPTIONS_FLAGS_ON='-fhandle-exceptions'
@@ -6258,8 +6259,9 @@
         MOZ_ENABLE_OLD_ABI_COMPAT_WRAPPERS=1
     ;;
     mips*)
-        CFLAGS="$CFLAGS -Wa,-xgot"
-        CXXFLAGS="$CXXFLAGS -Wa,-xgot"
+	CFLAGS="$CFLAGS -mips32r2 -pipe"
+	CXXFLAGS="$CXXFLAGS -mips32r2 -pipe"        
+	#MOZ_DEBUG_FLAGS="-g" # We want inlining
     ;;
     esac
     ;;
diff -ruNa mozilla-orig/js/src/js.c mozilla/js/src/js.c
--- mozilla-orig/js/src/js.c	2008-04-12 06:24:55.000000000 +0800
+++ mozilla/js/src/js.c	2008-07-17 19:25:17.000000000 +0800
@@ -132,8 +132,8 @@
 
 #ifdef EDITLINE
 JS_BEGIN_EXTERN_C
-extern char     *readline(const char *prompt);
-extern void     add_history(char *line);
+extern JS_EXPORT_API(char)     *readline(const char *prompt);
+extern JS_EXPORT_API(void)     add_history(char *line);
 JS_END_EXTERN_C
 #endif
 
diff -ruNa mozilla-orig/js/src/xpconnect/shell/Makefile.in mozilla/js/src/xpconnect/shell/Makefile.in
--- mozilla-orig/js/src/xpconnect/shell/Makefile.in	2008-01-17 04:42:51.000000000 +0800
+++ mozilla/js/src/xpconnect/shell/Makefile.in	2008-07-17 19:46:42.000000000 +0800
@@ -57,7 +57,9 @@
 LIBS		= \
 		$(DIST)/lib/$(LIB_PREFIX)xpcomglue_s.$(LIB_SUFFIX) \
 		$(MOZ_JS_LIBS) \
+		-Wl,--no-as-needed \
 		$(XPCOM_LIBS) \
+		-Wl,--as-needed \
 		$(NSPR_LIBS) \
 		$(NULL)
 
diff -ruNa mozilla-orig/js/src/xpconnect/shell/xpcshell.cpp mozilla/js/src/xpconnect/shell/xpcshell.cpp
--- mozilla-orig/js/src/xpconnect/shell/xpcshell.cpp	2008-04-19 01:51:10.000000000 +0800
+++ mozilla/js/src/xpconnect/shell/xpcshell.cpp	2008-07-17 19:45:36.000000000 +0800
@@ -594,8 +594,8 @@
 
 #ifdef EDITLINE
 extern "C" {
-extern char     *readline(const char *prompt);
-extern void     add_history(char *line);
+extern JS_EXPORT_API(char)     *readline(const char *prompt);
+extern JS_EXPORT_API(void)     add_history(char *line);
 }
 #endif
 
diff -ruNa mozilla-orig/netwerk/cookie/src/Makefile.in mozilla/netwerk/cookie/src/Makefile.in
--- mozilla-orig/netwerk/cookie/src/Makefile.in	2007-08-29 00:02:43.000000000 +0800
+++ mozilla/netwerk/cookie/src/Makefile.in	2008-07-17 21:15:55.000000000 +0800
@@ -60,5 +60,5 @@
 
 include $(topsrcdir)/config/rules.mk
 
-CXXFLAGS += $(WARNINGS_AS_ERRORS)
+#CXXFLAGS += $(WARNINGS_AS_ERRORS)
 DEFINES += -DIMPL_NS_NET
diff -ruNa mozilla-orig/security/coreconf/Linux.mk mozilla/security/coreconf/Linux.mk
--- mozilla-orig/security/coreconf/Linux.mk	2007-11-22 12:39:56.000000000 +0800
+++ mozilla/security/coreconf/Linux.mk	2008-07-17 19:57:53.000000000 +0800
@@ -117,8 +117,8 @@
 	OS_REL_CFLAGS   = -DLINUX1_2 -D_XOPEN_SOURCE
 	CPU_ARCH        = mips
 else
-	OS_REL_CFLAGS	= -DLINUX1_2 -Di386 -D_XOPEN_SOURCE
-	CPU_ARCH	= x86
+	OS_REL_CFLAGS	= -DLINUX1_2 -D_XOPEN_SOURCE
+	CPU_ARCH	= mips
 endif
 endif
 endif
diff -ruNa mozilla-orig/xpcom/build/nsXPComInit.cpp mozilla/xpcom/build/nsXPComInit.cpp
--- mozilla-orig/xpcom/build/nsXPComInit.cpp	2008-03-08 17:50:29.000000000 +0800
+++ mozilla/xpcom/build/nsXPComInit.cpp	2008-07-17 19:08:23.000000000 +0800
@@ -289,6 +289,23 @@
 static PRBool CheckUpdateFile()
 {
     nsresult rv;
+    nsCOMPtr<nsIFile> compregFile;
+    rv = nsDirectoryService::gService->Get(NS_XPCOM_COMPONENT_REGISTRY_FILE,
+                                           NS_GET_IID(nsIFile),
+                                           getter_AddRefs(compregFile));
+
+    if (NS_FAILED(rv)) {
+        NS_WARNING("Getting NS_XPCOM_COMPONENT_REGISTRY_FILE failed");
+        return PR_FALSE;
+    }
+
+    PRBool exists;
+    if (NS_FAILED(compregFile->Exists(&exists)) || !exists)
+        return PR_TRUE;
+
+    PRInt64 compregModTime;
+    compregFile->GetLastModifiedTime(&compregModTime);
+
     nsCOMPtr<nsIFile> file;
     rv = nsDirectoryService::gService->Get(NS_XPCOM_CURRENT_PROCESS_DIR, 
                                            NS_GET_IID(nsIFile), 
@@ -301,28 +318,40 @@
 
     file->AppendNative(nsDependentCString(".autoreg"));
     
-    PRBool exists;
     file->Exists(&exists);
     if (!exists)
-        return PR_FALSE;
+        goto next;
 
-    nsCOMPtr<nsIFile> compregFile;
-    rv = nsDirectoryService::gService->Get(NS_XPCOM_COMPONENT_REGISTRY_FILE,
+    PRInt64 autoregModTime;
+    file->GetLastModifiedTime(&autoregModTime);
+
+    if (LL_CMP(autoregModTime, >, compregModTime))
+        return PR_TRUE;
+
+next:
+    nsCOMPtr<nsIFile> greFile;
+    rv = nsDirectoryService::gService->Get(NS_GRE_DIR,
                                            NS_GET_IID(nsIFile),
-                                           getter_AddRefs(compregFile));
+                                           getter_AddRefs(greFile));
 
     
     if (NS_FAILED(rv)) {
-        NS_WARNING("Getting NS_XPCOM_COMPONENT_REGISTRY_FILE failed");
+        NS_WARNING("Getting NS_GRE_DIR failed");
         return PR_FALSE;
     }
 
-    if (NS_FAILED(compregFile->Exists(&exists)) || !exists)
-        return PR_TRUE;
+    greFile->AppendNative(nsDependentCString(".autoreg"));
 
-    PRInt64 compregModTime, autoregModTime;
-    compregFile->GetLastModifiedTime(&compregModTime);
-    file->GetLastModifiedTime(&autoregModTime);
+    PRBool equals;
+    rv = greFile->Equals(file, &equals);
+    if (NS_SUCCEEDED(rv) && equals)
+        return PR_FALSE;
+
+    greFile->Exists(&exists);
+    if (!exists)
+        return PR_FALSE;
+
+    greFile->GetLastModifiedTime(&autoregModTime);
 
     return LL_CMP(autoregModTime, >, compregModTime);
 }
diff -ruNa mozilla-orig/xpcom/glue/standalone/nsGlueLinkingDlopen.cpp mozilla/xpcom/glue/standalone/nsGlueLinkingDlopen.cpp
--- mozilla-orig/xpcom/glue/standalone/nsGlueLinkingDlopen.cpp	2006-02-02 00:51:12.000000000 +0800
+++ mozilla/xpcom/glue/standalone/nsGlueLinkingDlopen.cpp	2008-07-17 18:43:00.000000000 +0800
@@ -86,19 +86,20 @@
 GetFrozenFunctionsFunc
 XPCOMGlueLoad(const char *xpcomFile)
 {
-    char xpcomDir[MAXPATHLEN];
-    if (realpath(xpcomFile, xpcomDir)) {
-        char *lastSlash = strrchr(xpcomDir, '/');
-        if (lastSlash) {
-            *lastSlash = '\0';
+    char xulFile[MAXPATHLEN];
+    char *lastSlash = strrchr(xpcomFile, '/');
+    if (!lastSlash) {
+        snprintf(xulFile, MAXPATHLEN, "./%s", xpcomFile);
+        return XPCOMGlueLoad(xulFile);
+    }
+    *lastSlash = '\0';
 
-            XPCOMGlueLoadDependentLibs(xpcomDir, ReadDependentCB);
+    XPCOMGlueLoadDependentLibs(xpcomFile, ReadDependentCB);
+    snprintf(xulFile, MAXPATHLEN - strlen(xpcomFile), "%s/" XUL_DLL, xpcomFile);
 
-            snprintf(lastSlash, MAXPATHLEN - strlen(xpcomDir), "/" XUL_DLL);
+    sXULLibHandle = dlopen(xulFile, RTLD_GLOBAL | RTLD_LAZY);
 
-            sXULLibHandle = dlopen(xpcomDir, RTLD_GLOBAL | RTLD_LAZY);
-        }
-    }
+    *lastSlash = '/';
 
     // RTLD_DEFAULT is not defined in non-GNU toolchains, and it is
     // (void*) 0 in any case.
diff -ruNa mozilla-orig/xpcom/reflect/xptcall/src/md/unix/Makefile.in mozilla/xpcom/reflect/xptcall/src/md/unix/Makefile.in
--- mozilla-orig/xpcom/reflect/xptcall/src/md/unix/Makefile.in	2008-04-09 14:34:20.000000000 +0800
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/Makefile.in	2008-07-17 20:57:08.000000000 +0800
@@ -222,12 +222,13 @@
 # Linux/HPPA/gcc
 #
 ifeq ($(OS_ARCH),Linux)
-ifneq (,$(filter hppa2.0 hppa1.1,$(OS_TEST)))
+ifneq (,$(filter hppa hppa2.0 hppa1.1,$(OS_TEST)))
 ifndef GNU_CXX
 $(error Unknown C++ compiler, xptcall assembly will probably be incorrect.)
 else
 CPPSRCS		:= xptcinvoke_pa32.cpp xptcstubs_pa32.cpp
 ASFILES		:= xptcstubs_asm_parisc_linux.s xptcinvoke_asm_parisc_linux.s
+MOZ_OPTIMIZE_FLAGS	:= -O0
 endif
 endif
 endif
@@ -276,11 +277,7 @@
 ifneq (,$(findstring mips, $(OS_TEST)))
 CPPSRCS		:= xptcinvoke_mips.cpp xptcstubs_mips.cpp
 ASFILES		:= xptcinvoke_asm_mips.s xptcstubs_asm_mips.s
-#xptcstubs_mips.cpp
-# xptcstubs_asm_mips.s
-ifdef GNU_CC
-ASFLAGS		+= $(INCLUDES) -x assembler-with-cpp -D__GNUC__
-endif
+ASFLAGS		+= -I$(PUBLIC) -x assembler-with-cpp
 endif
 endif
 
@@ -466,13 +463,11 @@
 
 ifeq ($(OS_ARCH),Linux)
 ifneq (,$(findstring mips, $(OS_TEST)))
-xptcstubs_asm_mips.o: xptcstubs_asm_mips.s.m4 $(PUBLIC)/xptcstubsdef.inc
-	m4 $(INCLUDES) $< > ./xptcstubs_asm_mips.s && \
-	$(AS) -o $@ $(ASFLAGS) $(AS_DASH_C_FLAG) ./xptcstubs_asm_mips.s
-	$(RM) -f ./xptcstubs_asm_mips.s
+xptcstubs_asm_mips.o: $(PUBLIC)/xptcstubsdef.inc
 endif
 endif
 
+
 ifeq ($(OS_ARCH),Darwin)
 xptcstubs_asm_ppc_darwin.o: xptcstubs_asm_ppc_darwin.s.m4 $(PUBLIC)/xptcstubsdef.inc Makefile
 	gm4 $(INCLUDES) $< > ./xptcstubs_asm_ppc_darwin.s && \
diff -ruNa mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_asm_mips.s mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_asm_mips.s
--- mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_asm_mips.s	2006-12-11 17:45:39.000000000 +0800
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_asm_mips.s	2008-07-17 02:25:10.000000000 +0800
@@ -24,7 +24,7 @@
  * Contributor(s):
  *   Brendan Eich     <brendan@mozilla.org>
  *   Stuart Parmenter <pavlov@netscape.com>
- *
+ *   Thiemo Seufer    <seufer@csv.ica.uni-stuttgart.de>
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
@@ -44,139 +44,126 @@
 #include <sys/regdef.h>
 #include <sys/asm.h>
 
-.text
-.globl  invoke_count_words
-.globl	invoke_copy_to_stack 
-
-# We need a variable number of words allocated from the stack for copies of
-# the params, and this space must come between the high frame (where ra, gp,
-# and s0 are saved) and the low frame (where a0-a3 are saved by the callee
-# functions we invoke). 
-
-LOCALSZ=4		# s0, s1, ra, gp
-NARGSAVE=4		# a0, a1, a2, a3
-HIFRAMESZ=(LOCALSZ*SZREG)
-LOFRAMESZ=(NARGSAVE*SZREG)
-FRAMESZ=(HIFRAMESZ+LOFRAMESZ+ALSZ)&ALMASK
-
-# XXX these 2*SZREG, etc. are very magic -- we *know* that ALSZ&ALMASK cause
-# FRAMESZ to be 0 mod 8, in this case to be 16 and not 12.
-RAOFF=FRAMESZ - (2*SZREG)
-GPOFF=FRAMESZ - (3*SZREG)
-S0OFF=FRAMESZ - (4*SZREG)
-S1OFF=FRAMESZ - (5*SZREG)
-
-# These are not magic -- they are just our argsave slots in the caller frame.
-A0OFF=FRAMESZ
-A1OFF=FRAMESZ + (1*SZREG)
-A2OFF=FRAMESZ + (2*SZREG)
-A3OFF=FRAMESZ + (3*SZREG)
-
-	#	
-	# _XPTC_InvokeByIndex(that, methodIndex, paramCount, params)
-	#                      a0       a1          a2         a3
-
-NESTED(_XPTC_InvokeByIndex, FRAMESZ, ra)
-
-	.set	noreorder
-	.cpload	t9
-	.set	reorder
+
+# NARGSAVE is the argument space in the callers frame, including extra
+# 'shadowed' space for the argument registers. The minimum of 4
+# argument slots is sometimes predefined in the header files.
+#ifndef NARGSAVE
+#define NARGSAVE 4
+#endif
+
+#define LOCALSZ 3	/* gp, fp, ra */
+#define FRAMESZ ((((NARGSAVE+LOCALSZ)*SZREG)+ALSZ)&ALMASK)
+
+#define RAOFF (FRAMESZ - (1*SZREG))
+#define FPOFF (FRAMESZ - (2*SZREG))
+#define GPOFF (FRAMESZ - (3*SZREG))
+
+#define A0OFF (FRAMESZ + (0*SZREG))
+#define A1OFF (FRAMESZ + (1*SZREG))
+#define A2OFF (FRAMESZ + (2*SZREG))
+#define A3OFF (FRAMESZ + (3*SZREG))
+
+	.text
+
+#	
+# _NS_InvokeByIndex_P(that, methodIndex, paramCount, params)
+#                      a0       a1          a2         a3
+
+	.globl	_NS_InvokeByIndex_P
+	.align	2
+	.type	_NS_InvokeByIndex_P,@function
+	.ent	_NS_InvokeByIndex_P,0
+	.frame	fp, FRAMESZ, ra
+_NS_InvokeByIndex_P:
+	SETUP_GP
 
 	subu	sp, FRAMESZ
 
-	# specify the save register mask -- XXX do we want the a0-a3 here, given
-	# our "split" frame where the args are saved below a dynamicly allocated
-	# region under the high frame?
-	#
-	# 10010000000000010000000011110000
-	.mask 0x900100F0, -((NARGSAVE+LOCALSZ)*SZREG)
-
-	# thou shalt not use .cprestore if yer frame has variable size...
-	# .cprestore GPOFF
-
-	REG_S	ra, RAOFF(sp)
-
-	# this happens automatically with .cprestore, but we cannot use that op...
-	REG_S	gp, GPOFF(sp)
-	REG_S	s0, S0OFF(sp)
-	REG_S	s1, S1OFF(sp)
-
-	REG_S	a0, A0OFF(sp)
-	REG_S	a1, A1OFF(sp)
-	REG_S	a2, A2OFF(sp)
-	REG_S	a3, A3OFF(sp)
+	# specify the save register mask for gp, fp, ra, a3 - a0
+	.mask 0xD00000F0, RAOFF-FRAMESZ
 
-	# invoke_count_words(paramCount, params)
-	move	a0, a2
-	move	a1, a3
+	sw	ra, RAOFF(sp)
+	sw	fp, FPOFF(sp)
 
-	jal	invoke_count_words
-	lw	gp, GPOFF(sp)
+	# we can't use .cprestore in a variable stack frame
+	sw	gp, GPOFF(sp)
 
-	# save the old sp so we can pop the param area and any "low frame"
-	# needed as an argsave area below the param block for callees that
-	# we invoke.
-	move	s0, sp
-
-	REG_L	a1, A2OFF(sp)	# a1 = paramCount
-	REG_L	a2, A3OFF(sp)	# a2 = params
-
-	# we define a word as 4 bytes, period end of story!
-	sll	v0, 2		# 4 bytes * result of invoke_copy_words
-	subu	v0, LOFRAMESZ	# but we take back the argsave area built into
-				# our stack frame -- SWEET!
-	subu	sp, sp, v0	# make room
-	move	a0, sp		# a0 = param stack address
-	move	s1, a0		# save it for later -- it should be safe here
-
-	# the old sp is still saved in s0, but we now need another argsave
-	# area ("low frame") for the invoke_copy_to_stack call.
-	subu	sp, sp, LOFRAMESZ
+	sw	a0, A0OFF(sp)
+	sw	a1, A1OFF(sp)
+	sw	a2, A2OFF(sp)
+	sw	a3, A3OFF(sp)
+
+	# save bottom of fixed frame
+	move	fp, sp
+
+	# extern "C" uint32
+	# invoke_count_words(PRUint32 paramCount, nsXPTCVariant* s);
+	la	t9, invoke_count_words
+	move	a0, a2
+	move	a1, a3
+	jalr	t9
+	lw  	gp, GPOFF(fp)
 
-	# copy the param into the stack areas
+	# allocate variable stack, with a size of:
+	# wordsize (of 4 bytes) * result (already aligned to dword)
+	# but a minimum of 16 byte
+	sll	v0, 2
+	slt	t0, v0, 16
+	beqz	t0, 1f
+	li	v0, 16
+1:	subu	sp, v0
+
+	# let a0 point to the bottom of the variable stack, allocate
+	# another fixed stack for:
+	# extern "C" void
 	# invoke_copy_to_stack(PRUint32* d, PRUint32 paramCount,
-	#                      nsXPTCVariant* s)
-	jal     invoke_copy_to_stack
-	lw  	gp, GPOFF(s0)
-
-	move	sp, s0		# get orig sp back, popping params and argsave
-
-	REG_L	a0, A0OFF(sp)	# a0 = set "that" to be "this"
-	REG_L	a1, A1OFF(sp)	# a1 = methodIndex
-
-	# t1 = methodIndex * 4
-	# (use shift instead of mult)
-	sll	t1, a1, 2
-
-	# calculate the function we need to jump to,
-	# which must then be saved in t9
+	#		       nsXPTCVariant* s);
+	la	t9, invoke_copy_to_stack
+	move	a0, sp
+	lw	a1, A2OFF(fp)
+	lw	a2, A3OFF(fp)
+	subu	sp, 16
+	jalr	t9
+	lw  	gp, GPOFF(fp)
+
+	# back to the variable stack frame
+	addu	sp, 16
+
+	# calculate the function we need to jump to, which must then be
+	# stored in t9
+	lw	a0, A0OFF(fp)	# a0 = set "that" to be "this"
+	lw	t0, A1OFF(fp)	# a1 = methodIndex
 	lw	t9, 0(a0)
-	addu	t9, t9, t1
-	lw	t9, 8(t9)
-
-	# a1..a3 and f13..f14 should now be set to what
-	# invoke_copy_to_stack told us. skip a0 and f12
-	# because that is the "this" pointer
-
-	REG_L	a1, 1*SZREG(s1)
-	REG_L	a2, 2*SZREG(s1)
-	REG_L	a3, 3*SZREG(s1)
+	# t0 = methodIndex << PTRLOG
+	sll	t0, t0, PTRLOG
+	addu	t9, t0
+#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100 /* G++ V3 ABI */
+	lw	t9, (t9)
+#else /* not G++ V3 ABI */
+	lw	t9, 2*PTRSIZE(t9)
+#endif /* G++ V3 ABI */
+
+	# Set a1-a3 to what invoke_copy_to_stack told us. a0 is already
+	# the "this" pointer. We don't have to care about floating
+	# point arguments, the non-FP "this" pointer as first argument
+	# means they'll never be used.
+	lw	a1, 1*SZREG(sp)
+	lw	a2, 2*SZREG(sp)
+	lw	a3, 3*SZREG(sp)
+
+	jalr	t9
+	# Micro-optimization: There's no gp usage below this point, so
+	# we don't reload.
+	# lw	gp, GPOFF(fp)
 
-	l.d	$f13, 8(s1)
-	l.d	$f14, 16(s1)
+	# leave variable stack frame
+	move	sp, fp
 
-	# Create the stack pointer for the function, which must have 4 words
-	# of space for callee-saved args.  invoke_count_words allocated space
-        # for a0 starting at s1, so we just move s1 into sp.
-	move	sp, s1
+	lw	ra, RAOFF(sp)
+	lw	fp, FPOFF(sp)
 
-	jalr	ra, t9
-	lw	gp, GPOFF(s0)
-
-	move	sp, s0
-
-	REG_L	ra, RAOFF(sp)
-	REG_L	s0, S0OFF(sp)
-	addu	sp, FRAMESZ
+	addiu	sp, FRAMESZ
 	j	ra
-.end _XPTC_InvokeByIndex
+END(_NS_InvokeByIndex_P)
+
diff -ruNa mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_mips.cpp mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_mips.cpp
--- mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_mips.cpp	2004-04-18 22:18:18.000000000 +0800
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_mips.cpp	2008-07-16 18:35:19.000000000 +0800
@@ -24,6 +24,7 @@
  * Contributor(s):
  *   Stuart Parmenter <pavlov@netscape.com>
  *   Brendan Eich     <brendan@mozilla.org>
+ *   Thiemo Seufer    <seufer@csv.ica.uni-stuttgart.de>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
@@ -52,10 +53,9 @@
     // Count a word for a0 even though it's never stored or loaded
     // We do this only for alignment of register pairs.
     PRUint32 result = 1;
-    for (PRUint32 i = 0; i < paramCount; i++, s++)
-    {
-        result++;
+    for (PRUint32 i = 0; i < paramCount; i++, result++, s++)
 
+    {
         if (s->IsPtrData())
             continue;
 
@@ -68,6 +68,9 @@
 		result++;
 	    result++;
 	    break;
+        default:
+            break;
+
         }
     }
     return (result + 1) & ~(PRUint32)1;
@@ -88,8 +91,6 @@
             continue;
         }
 
-        *((void**)d) = s->val.p;
-
         switch(s->type)
         {
         case nsXPTType::T_I64    :
@@ -104,19 +105,21 @@
             if ((PRWord)d & 4) d++;
             *((double*)   d) = s->val.d;      d++;
             break;
+        default:
+            *((void**)d) = s->val.p;
+            break;
         }
     }
 }
 
-extern "C" nsresult _XPTC_InvokeByIndex(nsISupports* that, PRUint32 methodIndex,
+extern "C" nsresult _NS_InvokeByIndex_P(nsISupports* that, PRUint32 methodIndex,
                                         PRUint32 paramCount,
                                         nsXPTCVariant* params);
 
-extern "C"
-XPTC_PUBLIC_API(nsresult)
-XPTC_InvokeByIndex(nsISupports* that, PRUint32 methodIndex,
+EXPORT_XPCOM_API(nsresult)
+NS_InvokeByIndex_P(nsISupports* that, PRUint32 methodIndex,
                    PRUint32 paramCount, nsXPTCVariant* params)
 {
-    return _XPTC_InvokeByIndex(that, methodIndex, paramCount, params);
-}    
+    return _NS_InvokeByIndex_P(that, methodIndex, paramCount, params);
+}
 
diff -ruNa mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_mips.s mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_mips.s
--- mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_mips.s	1970-01-01 08:00:00.000000000 +0800
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_mips.s	2008-07-17 01:21:14.000000000 +0800
@@ -0,0 +1,143 @@
+/* -*- Mode: asm; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corp, Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2001
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Stuart Parmenter <pavlov@netscape.com>
+ *   Chris Waterson   <waterson@netscape.com>
+ *   Thiemo Seufer    <seufer@csv.ica.uni-stuttgart.de>
+ */
+
+/* This code is for MIPS using the O32 ABI. */
+
+#include <sys/regdef.h>
+#include <sys/asm.h>
+
+# NARGSAVE is the argument space in the callers frame, including extra
+# 'shadowed' space for the argument registers. The minimum of 4
+# argument slots is sometimes predefined in the header files.
+#ifndef NARGSAVE
+#define NARGSAVE 4
+#endif
+
+#define LOCALSZ 2	/* gp, ra */
+#define FRAMESZ ((((NARGSAVE+LOCALSZ)*SZREG)+ALSZ)&ALMASK)
+
+#define RAOFF (FRAMESZ - (1*SZREG))
+#define GPOFF (FRAMESZ - (2*SZREG))
+
+#define A0OFF (FRAMESZ + (0*SZREG))
+#define A1OFF (FRAMESZ + (1*SZREG))
+#define A2OFF (FRAMESZ + (2*SZREG))
+#define A3OFF (FRAMESZ + (3*SZREG))
+
+	.text
+
+#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100 /* G++ V3 ABI */
+#define STUB_ENTRY(x)						\
+	.if x < 10;						\
+	.globl	_ZN14nsXPTCStubBase5Stub ##x ##Ev;		\
+	.type	_ZN14nsXPTCStubBase5Stub ##x ##Ev,@function;	\
+	.aent	_ZN14nsXPTCStubBase5Stub ##x ##Ev,0;		\
+_ZN14nsXPTCStubBase5Stub ##x ##Ev:;				\
+	SETUP_GP;						\
+	li	t0,x;						\
+	b	sharedstub;					\
+	.elseif x < 100;					\
+	.globl	_ZN14nsXPTCStubBase6Stub ##x ##Ev;		\
+	.type	_ZN14nsXPTCStubBase6Stub ##x ##Ev,@function;	\
+	.aent	_ZN14nsXPTCStubBase6Stub ##x ##Ev,0;		\
+_ZN14nsXPTCStubBase6Stub ##x ##Ev:;				\
+	SETUP_GP;						\
+	li	t0,x;						\
+	b	sharedstub;					\
+	.elseif x < 1000;					\
+	.globl	_ZN14nsXPTCStubBase7Stub ##x ##Ev;		\
+	.type	_ZN14nsXPTCStubBase7Stub ##x ##Ev,@function;	\
+	.aent	_ZN14nsXPTCStubBase7Stub ##x ##Ev,0;		\
+_ZN14nsXPTCStubBase7Stub ##x ##Ev:;				\
+	SETUP_GP;						\
+	li	t0,x;						\
+	b	sharedstub;					\
+	.else;							\
+	.err;							\
+	.endif
+#else /* not G++ V3 ABI */
+#define STUB_ENTRY(x)						\
+	.globl	Stub ##x ##__14nsXPTCStubBase;			\
+	.type	Stub ##x ##__14nsXPTCStubBase,@function;	\
+	.aent	Stub ##x ##__14nsXPTCStubBase,0;		\
+Stub ##x ##__14nsXPTCStubBase:;					\
+	SETUP_GP;						\
+	li	t0,x;						\
+	b	sharedstub
+#endif /* G++ V3 ABI */
+
+# SENTINEL_ENTRY is handled in the cpp file.
+#define SENTINEL_ENTRY(x)
+
+#
+# open a dummy frame for the function entries
+#
+	.align	2
+	.type	dummy,@function
+	.ent	dummy, 0
+	.frame	sp, FRAMESZ, ra 
+dummy:
+	SETUP_GP
+
+#include "xptcstubsdef.inc"
+
+sharedstub:
+	subu	sp, FRAMESZ
+
+	# specify the save register mask for gp, ra, a0-a3
+	.mask 0x900000F0, RAOFF-FRAMESZ
+
+	sw	ra, RAOFF(sp)
+	SAVE_GP(GPOFF)
+
+	# Micro-optimization: a0 is already loaded, and its slot gets
+	# ignored by PrepareAndDispatch, so no need to save it here.
+	# sw	a0, A0OFF(sp)
+	sw	a1, A1OFF(sp)
+	sw	a2, A2OFF(sp)
+	sw	a3, A3OFF(sp)
+
+	la	t9, PrepareAndDispatch
+
+	# t0 is methodIndex
+	move	a1, t0
+	# have a2 point to the begin of the argument space on stack
+	addiu	a2, sp, FRAMESZ
+
+	# PrepareAndDispatch(that, methodIndex, args)
+	jalr	t9
+
+	# Micro-optimization: Using jalr explicitly has the side-effect
+	# of not triggering .cprestore. This is ok because we have no
+	# gp reference below this point. It also allows better
+	# instruction sscheduling.
+	# lw	gp, GPOFF(fp)
+ 
+ 	lw	ra, RAOFF(sp)
+	addiu	sp, FRAMESZ
+	j	ra
+	END(dummy)
+
diff -ruNa mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_mips.s.m4 mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_mips.s.m4
--- mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_mips.s.m4	2004-04-18 22:18:18.000000000 +0800
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_asm_mips.s.m4	2008-07-16 18:00:19.000000000 +0800
@@ -1,9 +1,6 @@
 /* -*- Mode: asm; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
  * Version: MPL 1.1
  *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
@@ -24,86 +21,123 @@
  * Contributor(s):
  *   Stuart Parmenter <pavlov@netscape.com>
  *   Chris Waterson   <waterson@netscape.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
+ *   Thiemo Seufer    <seufer@csv.ica.uni-stuttgart.de>
+ */
 
 /* This code is for MIPS using the O32 ABI. */
 
 #include <sys/regdef.h>
 #include <sys/asm.h>
 
+# NARGSAVE is the argument space in the callers frame, including extra
+# 'shadowed' space for the argument registers. The minimum of 4
+# argument slots is sometimes predefined in the header files.
+#ifndef NARGSAVE
+#define NARGSAVE 4
+#endif
+
+#define LOCALSZ 2	/* gp, ra */
+#define FRAMESZ ((((NARGSAVE+LOCALSZ)*SZREG)+ALSZ)&ALMASK)
+
+#define RAOFF (FRAMESZ - (1*SZREG))
+#define GPOFF (FRAMESZ - (2*SZREG))
+
+#define A0OFF (FRAMESZ + (0*SZREG))
+#define A1OFF (FRAMESZ + (1*SZREG))
+#define A2OFF (FRAMESZ + (2*SZREG))
+#define A3OFF (FRAMESZ + (3*SZREG))
+
 	.text
-	.globl PrepareAndDispatch
 
-NARGSAVE=4  # extra space for the callee to use.  gccism
-            # we can put our a0-a3 in our callers space.
-LOCALSZ=2   # gp, ra
-FRAMESZ=(((NARGSAVE+LOCALSZ)*SZREG)+ALSZ)&ALMASK
-
-define(STUB_NAME, `Stub'$1`__14nsXPTCStubBase')
-
-define(STUB_ENTRY,
-`	.globl		'STUB_NAME($1)`
-	.align		2
-	.type		'STUB_NAME($1)`,@function
-	.ent		'STUB_NAME($1)`, 0
-'STUB_NAME($1)`:
-	.frame		sp, FRAMESZ, ra 
-	.set		noreorder
-	.cpload		t9
-	.set		reorder
-	subu		sp, FRAMESZ
-	.cprestore	16	
-	li		t0, '$1`
-	b		sharedstub
-.end			'STUB_NAME($1)`
+#if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100 /* G++ V3 ABI */
+#define STUB_ENTRY(x)						\
+	.if x < 10;						\
+	.globl	_ZN14nsXPTCStubBase5Stub ##x ##Ev;		\
+	.type	_ZN14nsXPTCStubBase5Stub ##x ##Ev,@function;	\
+	.aent	_ZN14nsXPTCStubBase5Stub ##x ##Ev,0;		\
+_ZN14nsXPTCStubBase5Stub ##x ##Ev:;				\
+	SETUP_GP;						\
+	li	t0,x;						\
+	b	sharedstub;					\
+	.elseif x < 100;					\
+	.globl	_ZN14nsXPTCStubBase6Stub ##x ##Ev;		\
+	.type	_ZN14nsXPTCStubBase6Stub ##x ##Ev,@function;	\
+	.aent	_ZN14nsXPTCStubBase6Stub ##x ##Ev,0;		\
+_ZN14nsXPTCStubBase6Stub ##x ##Ev:;				\
+	SETUP_GP;						\
+	li	t0,x;						\
+	b	sharedstub;					\
+	.elseif x < 1000;					\
+	.globl	_ZN14nsXPTCStubBase7Stub ##x ##Ev;		\
+	.type	_ZN14nsXPTCStubBase7Stub ##x ##Ev,@function;	\
+	.aent	_ZN14nsXPTCStubBase7Stub ##x ##Ev,0;		\
+_ZN14nsXPTCStubBase7Stub ##x ##Ev:;				\
+	SETUP_GP;						\
+	li	t0,x;						\
+	b	sharedstub;					\
+	.else;							\
+	.err;							\
+	.endif
+#else /* not G++ V3 ABI */
+#define STUB_ENTRY(x)						\
+	.globl	Stub ##x ##__14nsXPTCStubBase;			\
+	.type	Stub ##x ##__14nsXPTCStubBase,@function;	\
+	.aent	Stub ##x ##__14nsXPTCStubBase,0;		\
+Stub ##x ##__14nsXPTCStubBase:;					\
+	SETUP_GP;						\
+	li	t0,x;						\
+	b	sharedstub
+#endif /* G++ V3 ABI */
+
+# SENTINEL_ENTRY is handled in the cpp file.
+#define SENTINEL_ENTRY(x)
+
+#
+# open a dummy frame for the function entries
+#
+	.align	2
+	.type	dummy,@function
+	.ent	dummy, 0
+	.frame	sp, FRAMESZ, ra 
+dummy:
+	SETUP_GP
 
-')
+#include "xptcstubsdef.inc"
 
-define(SENTINEL_ENTRY, `')
+sharedstub:
+	subu	sp, FRAMESZ
 
-include(xptcstubsdef.inc)
+	# specify the save register mask for gp, ra, a0-a3
+	.mask 0x900000F0, RAOFF-FRAMESZ
 
-	.globl	sharedstub
-	.ent	sharedstub
-sharedstub:
+	sw	ra, RAOFF(sp)
+	SAVE_GP(GPOFF)
 
-	REG_S	ra, 20(sp)
+	# Micro-optimization: a0 is already loaded, and its slot gets
+	# ignored by PrepareAndDispatch, so no need to save it here.
+	# sw	a0, A0OFF(sp)
+	sw	a1, A1OFF(sp)
+	sw	a2, A2OFF(sp)
+	sw	a3, A3OFF(sp)
 
-	REG_S	a0, 24(sp)
-	REG_S	a1, 28(sp)
-	REG_S	a2, 32(sp)
-	REG_S	a3, 36(sp)
+	la	t9, PrepareAndDispatch
 
 	# t0 is methodIndex
 	move	a1, t0
-
-	# put the start of a1, a2, a3, and stack
-	move	a2, sp
-	addi	a2, 24  # have a2 point to sp + 24 (where a0 is)
+	# have a2 point to the begin of the argument space on stack
+	addiu	a2, sp, FRAMESZ
 
 	# PrepareAndDispatch(that, methodIndex, args)
-	#                     a0       a1        a2
-	#
-	jal	PrepareAndDispatch
-
-	REG_L	ra, 20(sp)
-	REG_L	a1, 28(sp)
-	REG_L	a2, 32(sp)
+	jalr	t9
 
-	addu	sp, FRAMESZ
+	# Micro-optimization: Using jalr explicitly has the side-effect
+	# of not triggering .cprestore. This is ok because we have no
+	# gp reference below this point. It also allows better
+	# instruction sscheduling.
+	# lw	gp, GPOFF(fp)
+ 
+ 	lw	ra, RAOFF(sp)
+	addiu	sp, FRAMESZ
 	j	ra
+	END(dummy)
 
-.end sharedstub
diff -ruNa mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcstubs_mips.cpp mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_mips.cpp
--- mozilla-orig/xpcom/reflect/xptcall/src/md/unix/xptcstubs_mips.cpp	2004-04-18 22:18:18.000000000 +0800
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_mips.cpp	2008-07-15 22:07:24.000000000 +0800
@@ -39,6 +39,9 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "xptcprivate.h"
+#include "xptiprivate.h"
+
+//#include "nsIInterfaceInfo.h"
 
 /*
  * This is for MIPS O32 ABI
@@ -54,7 +57,7 @@
 
     nsXPTCMiniVariant paramBuffer[PARAM_BUFFER_COUNT];
     nsXPTCMiniVariant* dispatchParams = NULL;
-    nsIInterfaceInfo* iface_info = NULL;
+    //nsIInterfaceInfo* iface_info = NULL;
     const nsXPTMethodInfo* info;
     PRUint8 paramCount;
     PRUint8 i;
@@ -62,6 +65,7 @@
 
     NS_ASSERTION(self,"no self");
 
+/*
     self->GetInterfaceInfo(&iface_info);
     NS_ASSERTION(iface_info,"no interface info");
 
@@ -69,6 +73,11 @@
     NS_ASSERTION(info,"no interface info");
 
     paramCount = info->GetParamCount();
+*/
+
+    self->mEntry->GetMethodInfo(PRUint16(methodIndex), &info);
+    paramCount = info->GetParamCount();
+
 
     // setup variant array pointer
     if(paramCount > PARAM_BUFFER_COUNT)
@@ -109,9 +118,11 @@
         }
     }
 
-    result = self->CallMethod((PRUint16)methodIndex, info, dispatchParams);
+//    result = self->CallMethod((PRUint16)methodIndex, info, dispatchParams);
+    result = self->mOuter->CallMethod((PRUint16)methodIndex, info, dispatchParams);
+
 
-    NS_RELEASE(iface_info);
+//    NS_RELEASE(iface_info);
 
     if(dispatchParams != paramBuffer)
         delete [] dispatchParams;
