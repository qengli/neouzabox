diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/configs/tango2_defconfig linux-2.6.15/arch/mips/configs/tango2_defconfig
--- linux-2.6.15.ref/arch/mips/configs/tango2_defconfig	2008-01-18 17:56:56.000000000 -0800
+++ linux-2.6.15/arch/mips/configs/tango2_defconfig	2008-01-18 17:57:48.000000000 -0800
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.15
-# Fri Aug 11 09:54:22 2006
+# Tue Mar  6 10:24:42 2007
 #
 CONFIG_MIPS=y
 
@@ -76,6 +76,7 @@
 #
 # 
 #
+CONFIG_TANGOX_HZ_VALUE=1000
 CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE=64
 # CONFIG_TANGOX_IGNORE_CMDLINE is not set
 # CONFIG_TANGOX_PROM_CONSOLE is not set
@@ -393,9 +394,18 @@
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_BLK_DEV_BMIDE_TANGOX=y
+CONFIG_BLK_DEV_BMIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_PBIDE_TANGOX=y
+CONFIG_BLK_DEV_PBIDE_TANGOX_DMA=y
+# CONFIG_SD_CDROM_MAXIMUM_SECTOR_RESTRICTION is not set
+CONFIG_SD_CDROM_WAIT=y
+CONFIG_SD_CDROM_WAIT_TIME=5
+CONFIG_SD_CDROM_KEEP_DMA=y
+CONFIG_SD_CDROM_DMAPACKET=y
 # CONFIG_IDE_ARM is not set
-# CONFIG_BLK_DEV_IDEDMA is not set
-# CONFIG_IDEDMA_AUTO is not set
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/configs/tango3_defconfig linux-2.6.15/arch/mips/configs/tango3_defconfig
--- linux-2.6.15.ref/arch/mips/configs/tango3_defconfig	2008-01-18 17:56:56.000000000 -0800
+++ linux-2.6.15/arch/mips/configs/tango3_defconfig	2008-01-18 17:57:48.000000000 -0800
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.15
-# Wed Aug 16 15:00:18 2006
+# Mon Oct 23 14:23:16 2006
 #
 CONFIG_MIPS=y
 
@@ -72,6 +72,7 @@
 # 
 #
 # CONFIG_TANGO3_DISABLE_HWFPU is not set
+CONFIG_TANGOX_HZ_VALUE=1000
 CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE=64
 # CONFIG_TANGOX_IGNORE_CMDLINE is not set
 # CONFIG_TANGOX_PROM_CONSOLE is not set
@@ -388,9 +389,17 @@
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_BLK_DEV_BMIDE_TANGOX=y
+CONFIG_BLK_DEV_BMIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_PBIDE_TANGOX=y
+CONFIG_BLK_DEV_PBIDE_TANGOX_DMA=y
+CONFIG_SD_CDROM_WAIT=y
+CONFIG_SD_CDROM_WAIT_TIME=5
+CONFIG_SD_CDROM_KEEP_DMA=y
+CONFIG_SD_CDROM_DMAPACKET=y
 # CONFIG_IDE_ARM is not set
-# CONFIG_BLK_DEV_IDEDMA is not set
-# CONFIG_IDEDMA_AUTO is not set
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/mm/cache.c linux-2.6.15/arch/mips/mm/cache.c
--- linux-2.6.15.ref/arch/mips/mm/cache.c	2006-01-25 20:51:10.000000000 -0800
+++ linux-2.6.15/arch/mips/mm/cache.c	2008-01-18 17:57:48.000000000 -0800
@@ -66,6 +66,14 @@
 	return 0;
 }
 
+/* write-back and invalidate dcache */
+void flush_dcache_range(void __user *userbuf, unsigned int len)
+{
+	unsigned long start_addr, addr;
+	for (start_addr = addr = (unsigned long)userbuf; addr < (start_addr + len); addr += PAGE_SIZE)
+		flush_data_cache_page(addr);
+}
+
 void __flush_dcache_page(struct page *page)
 {
 	struct address_space *mapping = page_mapping(page);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/block/ll_rw_blk.c linux-2.6.15/block/ll_rw_blk.c
--- linux-2.6.15.ref/block/ll_rw_blk.c	2006-01-25 20:51:15.000000000 -0800
+++ linux-2.6.15/block/ll_rw_blk.c	2008-01-18 17:57:48.000000000 -0800
@@ -28,6 +28,10 @@
 #include <linux/writeback.h>
 #include <linux/blkdev.h>
 
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+#include <scsi/sg.h>
+#endif
+
 /*
  * for max sense size
  */
@@ -2143,23 +2147,42 @@
 	unsigned long uaddr;
 	struct bio *bio;
 	int reading;
+ 	int dma_alignment = 0;
 
 	if (len > (q->max_sectors << 9))
 		return -EINVAL;
 	if (!len || !ubuf)
 		return -EINVAL;
 
-	reading = rq_data_dir(rq) == READ;
+	reading = (rq_data_dir(rq) == READ);
+
+	if (reading) {
+		if (!access_ok(VERIFY_WRITE, (void __user *)ubuf, len)) 
+			return -EFAULT;
+	} else if (!access_ok(VERIFY_READ, (void __user *)ubuf, len))
+		return -EFAULT;
 
 	/*
 	 * if alignment requirement is satisfied, map in user pages for
 	 * direct dma. else, set up kernel bounce buffers
 	 */
-	uaddr = (unsigned long) ubuf;
-	if (!(uaddr & queue_dma_alignment(q)) && !(len & queue_dma_alignment(q)))
+	uaddr = (unsigned long)ubuf;
+	dma_alignment = queue_dma_alignment(q);
+
+	if (((uaddr & dma_alignment) == 0) && ((len & dma_alignment) == 0)) {
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+		if (reading) 
+			dma_cache_inv(uaddr, len);
+		else
+			dma_cache_wback_inv(uaddr, len);
+#endif
 		bio = bio_map_user(q, NULL, uaddr, len, reading);
-	else
-		bio = bio_copy_user(q, uaddr, len, reading);
+		if (IS_ERR(bio)) {
+			/* the map operation failed, use copy instead */
+			bio = bio_copy_user(q, uaddr, len, reading);
+		} 
+	} else 
+ 		bio = bio_copy_user(q, uaddr, len, reading);
 
 	if (!IS_ERR(bio)) {
 		rq->bio = rq->biotail = bio;
@@ -2201,11 +2224,23 @@
 int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
 			struct sg_iovec *iov, int iov_count)
 {
+	int i;
 	struct bio *bio;
 
 	if (!iov || iov_count <= 0)
 		return -EINVAL;
 
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+	for (i = 0; i < iov_count; i++) {
+		if (iov[i].iov_len) {
+			if (rq_data_dir(rq) == READ) 
+				dma_cache_inv((unsigned long)iov[i].iov_base, iov[i].iov_len);
+			else 
+				dma_cache_wback_inv((unsigned long)iov[i].iov_base, iov[i].iov_len);
+		}
+	}
+#endif
+
 	/* we don't allow misaligned data like bio_map_user() does.  If the
 	 * user is using sg, they're expected to know the alignment constraints
 	 * and respect them accordingly */
@@ -3203,7 +3238,6 @@
 	rq->hard_cur_sectors = rq->current_nr_sectors;
 	rq->hard_nr_sectors = rq->nr_sectors = bio_sectors(bio);
 	rq->buffer = bio_data(bio);
-
 	rq->bio = rq->biotail = bio;
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/block/scsi_ioctl.c linux-2.6.15/block/scsi_ioctl.c
--- linux-2.6.15.ref/block/scsi_ioctl.c	2006-01-25 20:51:15.000000000 -0800
+++ linux-2.6.15/block/scsi_ioctl.c	2008-01-18 17:57:48.000000000 -0800
@@ -455,7 +455,10 @@
 	rq->data_len = 0;
 	rq->timeout = BLK_DEFAULT_TIMEOUT;
 	memset(rq->cmd, 0, sizeof(rq->cmd));
-	rq->cmd[0] = cmd;
+	rq->cmd[0] = cmd & 0xff;
+	rq->cmd[1] = (cmd >> 8) & 0xff;
+	rq->cmd[2] = (cmd >> 16) & 0xff;
+	rq->cmd[3] = (cmd >> 24) & 0xff;
 	rq->cmd[4] = data;
 	rq->cmd_len = 6;
 	err = blk_execute_rq(q, bd_disk, rq, 0);
@@ -466,7 +469,7 @@
 
 static inline int blk_send_start_stop(request_queue_t *q, struct gendisk *bd_disk, int data)
 {
-	return __blk_send_generic(q, bd_disk, GPCMD_START_STOP_UNIT, data);
+	return __blk_send_generic(q, bd_disk, GPCMD_START_STOP_UNIT | 0x100 /* immed */, data);
 }
 
 int scsi_cmd_ioctl(struct file *file, struct gendisk *bd_disk, unsigned int cmd, void __user *arg)
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/cdrom/cdrom.c linux-2.6.15/drivers/cdrom/cdrom.c
--- linux-2.6.15.ref/drivers/cdrom/cdrom.c	2006-01-25 20:51:22.000000000 -0800
+++ linux-2.6.15/drivers/cdrom/cdrom.c	2008-01-18 17:57:48.000000000 -0800
@@ -1103,6 +1103,8 @@
 		}
 		else {
 		    cdinfo(CD_OPEN, "wrong media type, but CDO_CHECK_TYPE not set.\n");
+		    ret=-EMEDIUMTYPE;
+		    goto clean_up_and_return;
 		}
 	}
 
@@ -1446,10 +1448,12 @@
 	tracks->xa=0;
 	tracks->error=0;
 	cdinfo(CD_COUNT_TRACKS, "entering cdrom_count_tracks\n"); 
+#if 0
         if (!CDROM_CAN(CDC_PLAY_AUDIO)) { 
                 tracks->error=CDS_NO_INFO;
                 return;
         }        
+#endif
 	/* Grab the TOC header so we can see how many tracks there are */
 	if ((ret = cdi->ops->audio_ioctl(cdi, CDROMREADTOCHDR, &header))) {
 		if (ret == -ENOMEDIUM)
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/ide.c linux-2.6.15/drivers/ide/ide.c
--- linux-2.6.15.ref/drivers/ide/ide.c	2006-01-25 20:51:25.000000000 -0800
+++ linux-2.6.15/drivers/ide/ide.c	2008-01-18 17:57:48.000000000 -0800
@@ -805,6 +805,10 @@
 	hwif->chipset = hw->chipset;
 	hwif->gendev.parent = hw->dev;
 
+#if defined(CONFIG_BLK_DEV_BMIDE_TANGOX_MODULE) || defined(CONFIG_BLK_DEV_PBIDE_TANGOX_MODULE)
+	initializing = 1;
+#endif
+
 	if (!initializing) {
 		probe_hwif_init_with_fixup(hwif, fixup);
 		create_proc_ide_interfaces();
@@ -1854,6 +1858,18 @@
 #ifdef CONFIG_H8300
 	h8300_ide_init();
 #endif
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX
+	{
+		extern int __init tangox_bmide_init(void);
+		tangox_bmide_init();
+	}
+#endif
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX
+	{
+		extern int __init tangox_pbide_init(void);
+		tangox_pbide_init();
+	}
+#endif
 }
 
 void ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/ide-cd.c linux-2.6.15/drivers/ide/ide-cd.c
--- linux-2.6.15.ref/drivers/ide/ide-cd.c	2006-01-25 20:51:25.000000000 -0800
+++ linux-2.6.15/drivers/ide/ide-cd.c	2008-01-18 17:57:48.000000000 -0800
@@ -324,6 +324,11 @@
 
 #include "ide-cd.h"
 
+#ifdef CONFIG_SD_CDROM_WAIT
+#define CONFIG_SD_CDROM_WAIT_TICKS     (CONFIG_SD_CDROM_WAIT_TIME * HZ)
+static unsigned long cdrom_wait = 0;
+#endif
+
 static DECLARE_MUTEX(idecd_ref_sem);
 
 #define to_ide_cd(obj) container_of(obj, struct cdrom_info, kref) 
@@ -487,21 +492,15 @@
 
 		if (failed_command != NULL) {
 
-			int lo=0, mid, hi= ARY_LEN (packet_command_texts);
+			int lo=0, hi= ARY_LEN (packet_command_texts);
 			s = NULL;
 
-			while (hi > lo) {
-				mid = (lo + hi) / 2;
-				if (packet_command_texts[mid].packet_command ==
+			for (lo = 0; lo < hi; lo++) {
+				if (packet_command_texts[lo].packet_command ==
 				    failed_command->cmd[0]) {
-					s = packet_command_texts[mid].text;
+					s = packet_command_texts[lo].text;
 					break;
 				}
-				if (packet_command_texts[mid].packet_command >
-				    failed_command->cmd[0])
-					hi = mid;
-				else
-					lo = mid+1;
 			}
 
 			printk (KERN_ERR "  The failed \"%s\" packet command was: \n  \"", s);
@@ -630,6 +629,11 @@
 		nsectors = 1;
 
 	ide_end_request(drive, uptodate, nsectors);
+
+#ifdef CONFIG_SD_CDROM_WAIT
+        if (uptodate)
+		cdrom_wait = 0;
+#endif
 }
 
 /* Returns 0 if the request should be continued.
@@ -756,12 +760,31 @@
 			   too many times. */
 			if (++rq->errors > ERROR_MAX)
 				do_end_request = 1;
-		} else if (sense_key == ILLEGAL_REQUEST ||
-			   sense_key == DATA_PROTECT) {
+		} else if (sense_key == DATA_PROTECT) {
+			/* No point in retrying after an illegal
+			   request or data protect error.*/
+			ide_dump_status (drive, "command error", stat);
+			do_end_request = 1;
+		} else if (sense_key == ILLEGAL_REQUEST) {
+#ifdef CONFIG_SD_CDROM_WAIT
+			if (cdrom_wait == 0)
+				cdrom_wait = jiffies;
+			if (time_after(cdrom_wait + CONFIG_SD_CDROM_WAIT_TICKS, jiffies)) {
+				printk("%s: retrying operation.\n", drive->name);
+				do_end_request = 0;
+			} else {
+				/* No point in retrying after an illegal
+				   request or data protect error.*/
+				cdrom_wait = 0;
+				ide_dump_status (drive, "command error", stat);
+				do_end_request = 1;
+			}
+#else
 			/* No point in retrying after an illegal
 			   request or data protect error.*/
 			ide_dump_status (drive, "command error", stat);
 			do_end_request = 1;
+#endif
 		} else if (sense_key == MEDIUM_ERROR) {
 			/* No point in re-trying a zillion times on a bad 
 			 * sector...  If we got here the error is not correctable */
@@ -840,6 +863,16 @@
 	struct cdrom_info *info = drive->driver_data;
 	ide_hwif_t *hwif = drive->hwif;
 
+#ifdef CONFIG_SD_CDROM_DMAPACKET
+	struct request *rq = HWGROUP(drive)->rq;
+	if ((rq->cmd[0] != GPCMD_READ_10) &&
+			(rq->cmd[0] != GPCMD_READ_CD) &&
+			(rq->cmd[0] != GPCMD_WRITE_10) &&
+			(rq->cmd[0] != GPCMD_VERIFY_10) &&
+			(rq->cmd[0] != GPCMD_WRITE_AND_VERIFY_10))
+		info->dma = 0;
+#endif
+
 	/* Wait for the controller to be idle. */
 	if (ide_wait_stat(&startstop, drive, 0, BUSY_STAT, WAIT_READY))
 		return startstop;
@@ -1332,8 +1365,6 @@
 	if (cdrom_read_from_buffer(drive))
 		return ide_stopped;
 
-	blk_attempt_remerge(drive->queue, rq);
-
 	/* Clear the local sector buffer. */
 	info->nsectors_buffered = 0;
 
@@ -1874,14 +1905,6 @@
 		return ide_stopped;
 	}
 
-	/*
-	 * for dvd-ram and such media, it's a really big deal to get
-	 * big writes all the time. so scour the queue and attempt to
-	 * remerge requests, often the plugging will not have had time
-	 * to do this properly
-	 */
-	blk_attempt_remerge(drive->queue, rq);
-
 	info->nsectors_buffered = 0;
 
 	/* use dma, if possible. we don't need to check more, since we
@@ -2223,7 +2246,7 @@
 	stat = cdrom_read_capacity(drive, &toc->capacity, &sectors_per_frame,
 				   sense);
 	if (stat)
-		toc->capacity = 0x1fffff;
+		toc->capacity = 0x1ffffff; 
 
 	set_capacity(info->disk, toc->capacity * sectors_per_frame);
 	blk_queue_hardsect_size(drive->queue,
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/ide-iops.c linux-2.6.15/drivers/ide/ide-iops.c
--- linux-2.6.15.ref/drivers/ide/ide-iops.c	2006-01-25 20:51:25.000000000 -0800
+++ linux-2.6.15/drivers/ide/ide-iops.c	2008-01-18 17:57:48.000000000 -0800
@@ -1068,7 +1068,14 @@
 		if (drive->current_speed >= XFER_SW_DMA_0)
 			(void) HWIF(drive)->ide_dma_on(drive);
 	} else
-		(void)__ide_dma_off(drive);
+#ifdef CONFIG_SD_CDROM_KEEP_DMA
+		/* Turn off DMA only for HDD */
+		if (drive->media == ide_disk) {
+#endif
+			(void)__ide_dma_off(drive);
+#ifdef CONFIG_SD_CDROM_KEEP_DMA
+		}
+#endif
 #endif
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/ide-probe.c linux-2.6.15/drivers/ide/ide-probe.c
--- linux-2.6.15.ref/drivers/ide/ide-probe.c	2006-01-25 20:51:25.000000000 -0800
+++ linux-2.6.15/drivers/ide/ide-probe.c	2008-01-18 17:57:48.000000000 -0800
@@ -966,7 +966,11 @@
 {
 	request_queue_t *q;
 	ide_hwif_t *hwif = HWIF(drive);
+#ifndef MAX_KMALLOC_ORDER
 	int max_sectors = 256;
+#else
+	int max_sectors = (PAGE_SIZE<<MAX_KMALLOC_ORDER)>>9;
+#endif
 	int max_sg_entries = PRD_ENTRIES;
 
 	/*
@@ -982,7 +986,15 @@
 		return 1;
 
 	q->queuedata = drive;
+
+#if defined(CONFIG_BLK_DEV_BMIDE_TANGOX) || defined(CONFIG_BLK_DEV_PBIDE_TANGOX)
+	/* we  can handle  physical address  crossing  any boundaries,
+	 * this will make linux really merge all physically contiguous
+	 * bio */
+	blk_queue_segment_boundary(q, 0xffffffff);
+#else
 	blk_queue_segment_boundary(q, 0xffff);
+#endif
 
 	if (!hwif->rqsize) {
 		if (hwif->no_lba48 || hwif->no_lba48_dma)
@@ -990,8 +1002,19 @@
 		else
 			hwif->rqsize = 65536;
 	}
-	if (hwif->rqsize < max_sectors)
+	if ((hwif->rqsize < max_sectors) && (drive->media == ide_disk))
 		max_sectors = hwif->rqsize;
+
+#ifdef CONFIG_SD_CDROM_MAXIMUM_SECTOR_RESTRICTION
+        /*
+         * limits the max_sectors for some CDROM drives
+         */
+        if ((drive->media == ide_cdrom)){
+                max_sectors = CONFIG_SD_CDROM_MAXIMUM_SECTORS;
+                printk("The CDROM maximum sectors is set to 0x%x\n", max_sectors);
+        }
+#endif
+
 	blk_queue_max_sectors(q, max_sectors);
 
 #ifdef CONFIG_PCI
@@ -1119,9 +1142,9 @@
 	 */
 	if (!match || match->irq != hwif->irq) {
 		int sa = SA_INTERRUPT;
-#if defined(__mc68000__) || defined(CONFIG_APUS)
+#if defined(__mc68000__) || defined(CONFIG_APUS) || defined(CONFIG_TANGOX)
 		sa = SA_SHIRQ;
-#endif /* __mc68000__ || CONFIG_APUS */
+#endif /* __mc68000__ || CONFIG_APUS || CONFIG_TANGOX */
 
 		if (IDE_CHIPSET_IS_PCI(hwif->chipset)) {
 			sa = SA_SHIRQ;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/Kconfig linux-2.6.15/drivers/ide/Kconfig
--- linux-2.6.15.ref/drivers/ide/Kconfig	2006-01-25 20:51:25.000000000 -0800
+++ linux-2.6.15/drivers/ide/Kconfig	2008-01-18 17:57:48.000000000 -0800
@@ -812,6 +812,80 @@
        default "128"
        depends BLK_DEV_IDE_AU1XXX
 
+config BLK_DEV_BMIDE_TANGOX
+       select IDE_GENERIC
+       tristate "BMIDE for SMP863x/SMP865x"
+       depends on TANGOX
+       help
+         Enable the support for Bus Mastering IDE controller. 
+
+config BLK_DEV_BMIDE_TANGOX_DMA
+       select SD_CDROM_DMAPACKET if BLK_DEV_IDECD
+       bool "support BMIDE DMA operations"
+       default y
+       depends on BLK_DEV_BMIDE_TANGOX
+       help
+         Enable the DMA support for Bus Mastering IDE controller, which
+	 include support for MDMA and UDMA modes. 
+
+config BLK_DEV_PBIDE_TANGOX
+       select IDE_GENERIC
+       tristate "PBIDE for SMP863x/SMP865x"
+       depends on TANGOX
+       help
+         Enable the support for Peripheral Bus IDE controller. 
+
+config BLK_DEV_PBIDE_TANGOX_DMA
+       select SD_CDROM_DMAPACKET if BLK_DEV_IDECD
+       bool "support PBIDE DMA operations"
+       default y
+       depends on BLK_DEV_PBIDE_TANGOX
+       help
+         Enable the DMA support for Bus Mastering IDE controller, which
+	  include support for MDMA modes. 
+
+config SD_CDROM_MAXIMUM_SECTOR_RESTRICTION
+       bool "Limit CDROM maximum transfer sectors"
+       default n
+       depends on (BLK_DEV_BMIDE_TANGOX || BLK_DEV_PBIDE_TANGOX) && BLK_DEV_IDECD
+       help
+         Some CDROM has restriction on maximum tansfer sectors per request.
+
+config SD_CDROM_MAXIMUM_SECTORS
+       int "Maximum transfer sectors per request (in sectors)"
+       default 256
+       depends on SD_CDROM_MAXIMUM_SECTOR_RESTRICTION
+       help
+         How many maximum sectors can be tranferred per request.
+
+config SD_CDROM_WAIT
+       bool "enable CDROM wait for spin-up"
+       default y
+       depends on (BLK_DEV_BMIDE_TANGOX || BLK_DEV_PBIDE_TANGOX) && BLK_DEV_IDECD
+       help
+         Some CDROM implements spin-down control and hence will be spinned down after
+	 a period of inactivities. However, once the access started after spinned down,
+	 timeout may occured with I/O error. Enable this (and specify wait time) for
+	 your platform.
+
+config SD_CDROM_WAIT_TIME
+       int "CDROM spin-up wait time (in seconds)"
+       default 5
+       depends on SD_CDROM_WAIT
+       help
+         How long should the driver wait for CDROM spin-up.
+
+config SD_CDROM_KEEP_DMA
+       bool "Keep DMA mode even I/O failed on non-HDD"
+       default y
+       depends on ((BLK_DEV_BMIDE_TANGOX && BLK_DEV_BMIDE_TANGOX_DMA) || (BLK_DEV_PBIDE_TANGOX && BLK_DEV_PBIDE_TANGOX_DMA)) && BLK_DEV_IDECD 
+       help
+         Normally when DMA operation went bad, IDE layer may disable DMA and switch to
+	 PIO operation afterward. Enable this to keep DMA mode intact.
+
+config SD_CDROM_DMAPACKET
+	bool
+
 config IDE_ARM
 	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
 
@@ -1047,7 +1121,7 @@
 endif
 
 config BLK_DEV_IDEDMA
-	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA || BLK_DEV_BMIDE_TANGOX_DMA || BLK_DEV_PBIDE_TANGOX_DMA
 
 config IDEDMA_IVB
 	bool "IGNORE word93 Validation BITS"
@@ -1066,7 +1140,7 @@
 	  It is normally safe to answer Y; however, the default is N.
 
 config IDEDMA_AUTO
-	def_bool IDEDMA_PCI_AUTO || IDEDMA_ICS_AUTO
+	def_bool IDEDMA_PCI_AUTO || IDEDMA_ICS_AUTO || BLK_DEV_BMIDE_TANGOX_DMA || BLK_DEV_PBIDE_TANGOX_DMA
 
 endif
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/Makefile linux-2.6.15/drivers/ide/Makefile
--- linux-2.6.15.ref/drivers/ide/Makefile	2006-01-25 20:51:25.000000000 -0800
+++ linux-2.6.15/drivers/ide/Makefile	2008-01-18 17:57:48.000000000 -0800
@@ -48,6 +48,6 @@
 obj-$(CONFIG_BLK_DEV_IDETAPE)		+= ide-tape.o
 obj-$(CONFIG_BLK_DEV_IDEFLOPPY)		+= ide-floppy.o
 
-obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ arm/ mips/
+obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ arm/ mips/ tangox/
 obj-$(CONFIG_BLK_DEV_HD)		+= legacy/
 obj-$(CONFIG_ETRAX_IDE)		+= cris/
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/mips/Makefile linux-2.6.15/drivers/ide/mips/Makefile
--- linux-2.6.15.ref/drivers/ide/mips/Makefile	2006-01-25 20:51:25.000000000 -0800
+++ linux-2.6.15/drivers/ide/mips/Makefile	2008-01-18 17:57:48.000000000 -0800
@@ -1,4 +1,4 @@
 obj-$(CONFIG_BLK_DEV_IDE_SWARM)		+= swarm.o
 obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1xxx-ide.o
 
-CFLAGS_au1xxx-ide.o := -Idrivers/ide
+EXTRA_CFLAGS    := -Idrivers/ide
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/Makefile linux-2.6.15/drivers/ide/tangox/Makefile
--- linux-2.6.15.ref/drivers/ide/tangox/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/Makefile	2008-01-18 17:57:48.000000000 -0800
@@ -0,0 +1,4 @@
+obj-$(CONFIG_BLK_DEV_BMIDE_TANGOX)	+= tangox-bmide.o
+obj-$(CONFIG_BLK_DEV_PBIDE_TANGOX)	+= tangox-pbide.o
+
+EXTRA_CFLAGS	:= -I../
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/tangox-bmide.c linux-2.6.15/drivers/ide/tangox/tangox-bmide.c
--- linux-2.6.15.ref/drivers/ide/tangox/tangox-bmide.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/tangox-bmide.c	2008-01-18 18:06:52.000000000 -0800
@@ -0,0 +1,936 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ide.h>
+
+#include "tangox-ide.h"
+
+static DEFINE_SPINLOCK(bmide_tune_chipset_spin_lock);
+
+#define PFX	"tangox_bmide: "
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+#define CONFIG_BLK_DEV_BMIDE_TANGOX_UDMA /* enable UDMA as well */
+#endif
+
+/*
+ * helper to access host interface
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_readl(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_writel(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_readb(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_writeb(REG_BASE_host_interface + (r), (v))
+
+#define CONFIG_RUNTIME_CLK_CALC
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+typedef struct {
+	unsigned long cycle_time;
+	unsigned long active_time;
+	unsigned long recovery_time;
+	unsigned long setup_time;
+	unsigned long hold_time;
+} j2_tim_pio_dma_t;
+
+typedef struct {
+	unsigned long t_zah;//
+	unsigned long t_mli;//
+	unsigned long t_ack;//
+	unsigned long t_env;//
+	unsigned long t_rp;	//
+	unsigned long t_cyc;//
+	unsigned long t_cvh;//
+	unsigned long t_cvs;//
+} j2_tim_udma_t;
+
+static j2_tim_pio_dma_t	j2_pio_timings[] = 
+{
+//	 cycle	, active, recov	, setup	, hold
+	{600	, 165	, 70	, 70	, 30	},
+	{383	, 125	, 70	, 50	, 20	},
+	{240	, 100	, 70	, 30	, 15	},
+	{180	, 80	, 70	, 30	, 10	},
+	{120	, 70	, 25	, 25	, 10	},
+};
+
+static j2_tim_pio_dma_t	j2_dma_timings[] =
+{
+//	 cycle	, active, recov	, setup	, hold
+	{480	, 215	, 215	, 50	, 20	},
+	{150	, 80	, 50	, 30	, 15	},
+	{120	, 70	, 25	, 25	, 10	},
+};
+
+// We round 16.8 to 17 - Ex: mode 5, t_cyc=16.8!!!
+static j2_tim_udma_t j2_udma_timings[] =
+{
+//	 t_zah,  t_mli, t_ack,  t_env,  t_rp,  t_cyc   t_cvh   t_cvs
+	{ 20,	 20,	 20,	20,		160,	112,	  7,	 70	},
+	{ 20,	 20,	 20,	20,		125,	 73,	  7,	 48	},
+	{ 20,	 20,	 20,	20,		100,	 54,	  7,	 31	},
+	{ 20,	 20,	 20,	20,		100,	 39,	  7,	 20	},
+	{ 20,	 20,	 20,	20,		100,	 25,	  7,	  7	},
+	{ 20,	 20,	 20,	20,		 85,	 17,	 10,	 10	},
+	{ 20,	 20,	 20,	20,		 85,	 13,	 10,	 10	},
+	{ 20,	 20,	 20,	20,		 85,	 13,	 10,	 10	},
+};
+
+static unsigned int CalcRegValTiming_PIO_DMA(j2_tim_pio_dma_t *t, unsigned long ide_clock);
+static unsigned int CalcRegValTiming1_UDMA(j2_tim_udma_t *t, unsigned long ide_clock);
+static unsigned int CalcRegValTiming2_UDMA(j2_tim_udma_t *t, unsigned long ide_clock);
+#endif /* CONFIG_RUNTIME_CLK_CALC */
+
+/*
+ * io helpers for PIO access
+ */
+static void tangox_bmide_outb(u8 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_bmide_outw(u16 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_bmide_outbsync(ide_drive_t *drive, u8 data,
+				unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static u8 tangox_bmide_inb(unsigned long port)
+{
+	u8 val;
+
+	val = ((u8)(gbus_readw(port) & 0xff));
+	return val;
+}
+
+static u16 tangox_bmide_inw(unsigned long port)
+{
+	u16 val;
+
+	val = ((u16)(gbus_readw(port) & 0xffff));
+	return val;
+}
+
+static void tangox_bmide_insw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		*(u16 *)addr = (u16)(gbus_readw(port) & 0xffff);
+		addr += 2;
+	}
+}
+
+static void tangox_bmide_outsw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		gbus_writew(port, *(u16 *)addr);
+		addr += 2;
+	}
+}
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+/*
+ * returns closest pio mode timings from given dma speed
+ */
+static u8 dma_2_pio(u8 xfer_rate) {
+
+	switch (xfer_rate) {
+	case XFER_UDMA_6:
+	case XFER_UDMA_5:
+	case XFER_UDMA_4:
+	case XFER_UDMA_3:
+	case XFER_UDMA_2:
+	case XFER_UDMA_1:
+	case XFER_UDMA_0:
+	case XFER_MW_DMA_2:
+	case XFER_PIO_4:
+		return 4;
+
+	case XFER_MW_DMA_1:
+	case XFER_PIO_3:
+		return 3;
+
+	case XFER_SW_DMA_2:
+	case XFER_PIO_2:
+		return 2;
+
+	case XFER_MW_DMA_0:
+	case XFER_SW_DMA_1:
+	case XFER_SW_DMA_0:
+	case XFER_PIO_1:
+	case XFER_PIO_0:
+	case XFER_PIO_SLOW:
+	default:
+		return 0;
+	}
+}
+
+/*
+ * dma related callbacks
+ */
+int tangox_bmide_dma_host_on(ide_drive_t *drive)
+{
+	if (drive->using_dma) {
+		ide_hwif_t *hwif = HWIF(drive);
+		u8 unit = (drive->select.b.unit & 0x01);
+		u8 dma_stat = hwif->INB(hwif->dma_status);
+
+		hwif->OUTB((dma_stat | (1 << (5 + unit))), hwif->dma_status);
+		return 0;
+	}
+	return 1;
+}
+
+int tangox_bmide_dma_host_off(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 unit = (drive->select.b.unit & 0x01);
+	u8 dma_stat = hwif->INB(hwif->dma_status);
+
+	hwif->OUTB((dma_stat & ~(1 << (5 + unit))), hwif->dma_status);
+
+	return 0;
+}
+
+int tangox_bmide_dma_check(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct hd_driveid *id = drive->id;
+	u8 pio, speed;
+
+	drive->init_speed = 0;
+
+	/* check if the drive claim to dma-able */
+	if ((id->capability & 1) && drive->autodma && ide_use_dma(drive)) {
+		u8 mode;
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_UDMA
+		/* We can do all udma mode, but only with 80 conductor
+		 * cable */
+		mode = 4;
+		if ((gbus_readl(REG_BASE_host_interface +
+				IDECTRL_idestatus) & 0x02) == 0x02) {
+			printk("%s: no 80 conductors cable, falling back to "
+			       "lower udma mode\n", drive->name);
+			mode = 1;
+		}
+#else
+		mode = 0; /* max. MWDMA mode 2 */
+#endif
+
+		/* find a speed supported by the drive */
+		speed = ide_dma_speed(drive, mode);
+
+		if (speed >= XFER_MW_DMA_0) {
+			/* ok, we  have one, configure  chipset for it
+			 * and apply speed to the drive */
+			hwif->speedproc(drive, speed);
+			return hwif->ide_dma_on(drive);
+		}
+	}
+
+	/* fallback to pio mode */
+	pio = ide_get_best_pio_mode(drive, 255, 5, NULL);
+	speed = dma_2_pio(XFER_PIO_0 + pio) + XFER_PIO_0;
+	hwif->speedproc(drive, speed);
+	return hwif->ide_dma_off_quietly(drive);
+}
+
+int tangox_bmide_dma_on(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+
+	if (hwif->ide_dma_host_on)
+		hwif->ide_dma_host_on(drive);
+
+	if (drive->using_dma)
+		return 0;
+
+	printk("%s: DMA enabled for %s%s\n", hwif->name,
+	       drive->media == ide_disk ? "ATA DISK " :
+	       (drive->media == ide_cdrom ? "ATAPI CDROM " : ""),
+	       drive->name);
+	drive->using_dma = 1;
+
+	return 0;
+}
+
+int tangox_bmide_dma_off_quietly(ide_drive_t *drive)
+{
+	drive->using_dma = 0;
+	return 0;
+}
+
+/*
+ * dma operations
+ */
+static unsigned long g_mbus_reg = 0;
+static unsigned int g_next_sg = 0;
+
+static ide_startstop_t tangox_dma_intr(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat, stat;
+	struct request *rq;
+
+        dma_stat = hwif->ide_dma_end(drive);
+	stat = HWIF(drive)->INB(IDE_STATUS_REG);
+
+	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | DRQ_STAT)) {
+		if (!(dma_stat & 1)) {
+			rq = HWGROUP(drive)->rq;
+			ide_end_request(drive, 1, rq->nr_sectors);
+			return ide_stopped;
+		}
+		printk(KERN_ERR PFX "%s: bad DMA status (dma_stat=%x)\n",
+		       drive->name, dma_stat);
+	}
+
+	return ide_error(drive, "dma_intr", 0);
+}
+
+static void tangox_mbus_intr(int irq, void *arg)
+{
+	ide_drive_t *drive = (ide_drive_t *)arg;
+	ide_hwif_t *hwif = HWIF(drive);
+        struct scatterlist *sg;
+
+	if (drive->using_dma == 0) {
+		printk(KERN_ERR PFX "bug: tangox_mbus_intr called while "
+		       "using_dma == 0\n");
+		return;
+	}
+
+	if (g_next_sg > hwif->sg_nents)
+		return;
+	else if (g_next_sg == hwif->sg_nents) { /* no more */
+		g_next_sg++;
+		em86xx_mbus_setup_dma_void(g_mbus_reg);
+		return;
+	}
+
+	em86xx_mbus_wait(g_mbus_reg, SBOX_IDEDVD);
+
+	/*
+	 * setup a new mbus transfer
+	 */
+	sg = &hwif->sg_table[g_next_sg];
+	g_next_sg++;
+
+	if (em86xx_mbus_setup_dma(g_mbus_reg, sg_dma_address(sg), sg_dma_len(sg),
+				  tangox_mbus_intr, drive, 0)) {
+		printk(KERN_ERR PFX "fail to resetup dma, wait "
+		       "for timeout...\n");
+	}
+}
+
+static void tangox_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+	/* issue  cmd to  drive,  and register  interrupt handler  for
+	 * command completion */
+	ide_execute_command(drive, command, &tangox_dma_intr, (2 * WAIT_CMD),
+			    NULL);
+}
+
+/* Get the I/O size of given request */
+static inline int get_request_size(struct request *rq)
+{
+	unsigned int rq_size;
+	struct bio *bio;
+	
+	for (rq_size = 0, bio = rq->bio; bio != NULL; bio = bio->bi_next)
+		rq_size += bio->bi_size;
+	
+	return rq_size;
+}
+
+static void tangox_dma_start(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq;
+	unsigned long val, len;
+
+        rq = HWGROUP(drive)->rq;
+	len = get_request_size(rq);
+
+	/* setup IDE DMA transfer len */
+	gbus_writel(REG_BASE_host_interface + IDECTRL_ide_dmalen, len);
+
+	/* enable bus mastering */
+	val = 0x05;
+	if (hwif->sg_dma_direction == DMA_FROM_DEVICE)
+		val |= 0x8;
+
+	gbus_writel(REG_BASE_host_interface + IDECTRL_bmic, val);
+}
+
+static int tangox_dma_setup(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq;
+	int iswrite;
+        struct scatterlist *sg = hwif->sg_table;
+
+        rq = HWGROUP(drive)->rq;
+
+	iswrite = (rq_data_dir(rq) == WRITE);
+	hwif->sg_dma_direction = iswrite ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+
+	/*
+	 * ide_map_sg will merge contiguous memory zone for us
+	 */
+        ide_map_sg(drive, rq);
+
+	/* try to setup dma channel */
+	if (em86xx_mbus_alloc_dma(SBOX_IDEDVD, iswrite ? 0 : 1, &g_mbus_reg,
+				  NULL, 0)) {
+		printk(KERN_ERR PFX "fail to alloc dma, fallback to pio\n");
+		goto fallback_pio;
+	}
+
+	/*
+	 * map and transfer first segment
+	 */
+	dma_map_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	g_next_sg = 1;
+
+	/*
+	 * setup mbus dma for this address.  we want an mbus interrupt
+	 * only if this is not the last sg element,  so we can refeed
+	 * mbus.
+	 */
+	if (em86xx_mbus_setup_dma(g_mbus_reg, sg_dma_address(sg),
+				  sg_dma_len(sg),
+				  (hwif->sg_nents == 1) ? NULL : tangox_mbus_intr, 
+				  drive, 
+				  (hwif->sg_nents == 1) ? 1 : 0)) {
+		printk(KERN_ERR PFX "fail to setup dma, fallback to pio\n");
+		dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents,
+			     hwif->sg_dma_direction);
+		em86xx_mbus_free_dma(g_mbus_reg, SBOX_IDEDVD);
+		goto fallback_pio;
+	}
+
+	drive->waiting_for_dma = 1;
+	return 0;
+
+fallback_pio:
+	ide_map_sg(drive, rq);
+	return 1;
+}
+
+static int tangox_bmide_dma_end(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat;
+	int mbus_stat;
+        struct scatterlist *sg = hwif->sg_table;
+
+	dma_stat = hwif->INB(hwif->dma_status);
+
+	/*
+	 * make sure DMA is not in progress
+	 */
+	if ((dma_stat & 0x7) == 1) {
+		printk(KERN_ERR PFX "huh ? dma_end called while dma still "
+		       "in progress...\n");
+	}
+
+	/* clear the INTR & ERROR bits */
+	hwif->OUTB(dma_stat | 6, hwif->dma_status);
+
+	/*
+	 * confirm  whether MBUS transfer  is done  due to  the memory
+	 * arbitration, IDE  device thinks  the DMA transfer  is done,
+	 * but the data might be held in MBUS FIFO
+	 */
+	mbus_stat = em86xx_mbus_wait(g_mbus_reg, SBOX_IDEDVD);
+
+	/* release mbus */
+	em86xx_mbus_free_dma(g_mbus_reg, SBOX_IDEDVD);
+
+	/* stop bus mastering */
+	hwif->OUTB(0x4, hwif->dma_command);
+
+	dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents,
+		     hwif->sg_dma_direction);
+	drive->waiting_for_dma = 0;
+
+	/* fake  dma  error  in  case  of mbus  timeout,  else  return
+	 * dma_status error bit */
+	return (mbus_stat == 0) ? (dma_stat & 1) : 0x1;
+}
+
+static int tangox_bmide_dma_test_irq(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat;
+
+	dma_stat = hwif->INB(hwif->dma_status);
+	if ((dma_stat & 0x4))
+		return 1;
+	return 0;
+}
+
+static int tangox_bmide_dma_lostirq(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_bmide_dma_timeout(ide_drive_t *drive)
+{
+	return 0;
+}
+#endif
+
+#ifndef CONFIG_RUNTIME_CLK_CALC
+/*
+ * timing values for each ide mode
+ */
+static const unsigned int s_pio_tim[] = {
+	0xff230ee6, 0xd41b0fa4, 0xb4150f63, 0xa7110f62, 0x9a0f0552
+};
+
+static const unsigned int s_dma_tim[] = {
+	0xf33333b4, 0xa3130b73, 0x9c100552
+};
+static const unsigned int s_udma_tim1[] = {
+	0x35440b08, 0x35440a06, 0x35440804
+};
+static const unsigned int s_udma_tim2[] = {
+	0x00000208, 0x00000206, 0x00000204
+};
+
+static const unsigned int s_udma_tim1_alt[] = {
+	0x44442418, 0x44441c10, 0x4444160b, 0x44441608,
+	0x44441605, 0x44441303, 0x44441302, 0x44441302
+};
+static const unsigned int s_udma_tim2_alt[] = {
+	0x0000010f, 0x0000010a, 0x00000106, 0x00000104,
+	0x00000101, 0x00000202, 0x00000202, 0x00000202
+};
+#endif /* !CONFIG_RUNTIME_CLK_CALC */
+
+
+/*
+ * tangox_bmide_tune_drive
+ */
+static void tangox_bmide_tune_drive(ide_drive_t *drive, u8 pio)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+
+	if (pio == 255)
+		pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+	hwif->speedproc(drive, pio + XFER_PIO_0);
+}
+
+/*
+ * tangox_bmide_tune_chipset
+ */
+static int tangox_bmide_tune_chipset(ide_drive_t *drive, u8 xferspeed)
+{
+	int didx;
+	unsigned int ctrlreg, newflag;
+        unsigned long flags;
+	u8 mode, pio;
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+#define TIMING_MARGIN(x) (((x) * 105) / 100) /* add 5% margin */
+//#define TIMING_MARGIN(x) (x) /* no margin added */
+	extern unsigned long tangox_get_sysclock(void);
+	unsigned int ide_clock = TIMING_MARGIN(tangox_get_sysclock() / 1000000); /* in MHz */
+#endif
+	
+	didx = drive->select.b.unit;
+	newflag = 0;
+
+        spin_lock_irqsave(&bmide_tune_chipset_spin_lock, flags);
+
+	if (xferspeed >= XFER_PIO_0 && xferspeed <= XFER_PIO_4) {
+		/*
+		 * setup timing for PIO mode
+		 */
+		mode = xferspeed - XFER_PIO_0;
+		printk("%s: set to PIO mode %d\n", drive->name, mode);
+
+		/* fast timing for PIO */
+		newflag = 0x01;
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    CalcRegValTiming_PIO_DMA(&(j2_pio_timings[mode]), ide_clock));
+#else
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    s_pio_tim[mode]);
+#endif
+
+	}
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+	else if (xferspeed >= XFER_MW_DMA_0 && xferspeed <= XFER_MW_DMA_2) {
+		/*
+		 * setup timing for Multi-word DMA
+		 */
+		mode = xferspeed - XFER_MW_DMA_0;
+		printk("%s: set to Multi-word DMA mode %d\n", drive->name,
+		       mode);
+
+		/* fast timing for PIO, prefetch enable */
+		newflag = 0x05;
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    CalcRegValTiming_PIO_DMA(&(j2_dma_timings[mode]), ide_clock));
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim), 
+			    s_dma_tim[mode]);
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    s_udma_tim1[mode]);
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    s_udma_tim2[mode]);
+#endif
+
+	} 
+#endif
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_UDMA
+	else if (xferspeed >= XFER_UDMA_0 && xferspeed <= XFER_UDMA_7) {
+		unsigned int val;
+
+		/*
+		 * setup timing for Ultra DMA
+		 */
+		mode = xferspeed - XFER_UDMA_0;
+		printk("%s: set to Ultra DMA mode %d\n", drive->name, mode);
+
+		newflag = 0x00;
+
+		/* enable Ultra DMA */
+		val = gbus_readl(REG_BASE_host_interface + IDECTRL_udmactl);
+		val |= (didx == 0) ? 0x01 : 0x02;
+		gbus_writel(REG_BASE_host_interface + IDECTRL_udmactl, val);
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1), 
+			    s_udma_tim1_alt[mode]);
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2), 
+			    s_udma_tim2_alt[mode]);
+#endif
+ 	}
+#endif
+	else {
+		printk("%s: unknown speed to be set %d\n", drive->name, xferspeed);
+	}
+
+	ctrlreg = gbus_readl(REG_BASE_host_interface + IDECTRL_pri_idectl);
+	ctrlreg &= ~(didx == 0 ? 0xf : 0xf0);
+	ctrlreg |= newflag << (didx * 4);
+	gbus_writel(REG_BASE_host_interface + IDECTRL_pri_idectl, ctrlreg);
+
+	spin_unlock_irqrestore(&bmide_tune_chipset_spin_lock, flags);
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+	if (xferspeed >= XFER_SW_DMA_0)
+		pio = dma_2_pio(xferspeed);
+	else
+#endif
+		pio = xferspeed - XFER_PIO_0;
+
+	return ide_config_drive_speed(drive, xferspeed);
+}
+
+static void tangox_hw_setup(hw_regs_t *hw, unsigned long data_port,
+		     unsigned long ctrl_port)
+{
+	int i;
+	unsigned long reg;
+
+	memset(hw, 0, sizeof (*hw));
+
+	/* setup io_ports */
+	reg = data_port;
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = reg;
+		reg += 4;
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+}
+
+
+/*
+ * init function, ide controller is registred here
+ */
+extern int tangox_bmide_enabled(void);
+
+int __init tangox_bmide_init(void)
+{
+        ide_hwif_t *hwif;
+	hw_regs_t hw;
+	int index;
+	if (!tangox_bmide_enabled()) {
+		printk(KERN_NOTICE PFX "bmide support is disabled\n");
+		return -1;
+	}
+
+	/* Enable bus master IDE interface */
+	WR_HOST_REG32(IDECTRL_pri_idectl, 0x8400);
+
+	/* no skew : normal IORDY, normal data */
+	WR_HOST_REG32(IDECTRL_idesrc, 0);
+
+	/* Enable non-PRD mode */
+	WR_HOST_REG32(IDECTRL_bmic, 0x4);
+
+	/*
+	 * set register offset for our controller
+	 */
+	tangox_hw_setup(&hw, REG_BASE_host_interface_BMIDE,
+			REG_BASE_host_interface + IDECTRL_pri_ctrlblock);
+	hw.dma = NO_DMA;
+	/*
+	 * Tango   has   two   interrupts   for   IDE   controller   :
+	 * IRQ_IDECTRL_IDE,  IRQ_IDECTRL_IDEDMA
+	 *
+	 * IRQ_IDECTRL_IDEDMA is to be used for DMA transfer but it is
+	 * almost same with IRQ_IDECTRL_IDE interrupt.  Tango triggers
+	 * IDEDMA interrupt  after DMA FIFO  is flushed, and  it stays
+	 * high   until  BMIS   register  bit   2  is   cleared.   Use
+	 * IRQ_IDECTRL_IDE interrupt for both of PIO and DMA.
+	 */
+	hw.irq = IRQ_IDECTRL_IDE;
+
+	/*
+	 * register our controller
+	 */
+	if ((index = ide_register_hw(&hw, &hwif)) < 0) {
+		printk("failed to register SMP863x/SMP865x BM IDE controller\n");
+		return -1;
+	}
+
+	printk("%s: SMP863x/SMP865x Bus Mastering IDE controller\n", hwif->name);
+
+	/*
+	 * fill controller callbacks
+	 */
+
+        /* set up local I/O function entry points */
+        hwif->INB = tangox_bmide_inb;
+        hwif->INW = tangox_bmide_inw;
+        hwif->INSW = tangox_bmide_insw;
+        hwif->OUTB = tangox_bmide_outb;
+        hwif->OUTW = tangox_bmide_outw;
+        hwif->OUTBSYNC = tangox_bmide_outbsync;
+        hwif->OUTSW = tangox_bmide_outsw;
+
+	hwif->tuneproc = &tangox_bmide_tune_drive;
+        hwif->speedproc = &tangox_bmide_tune_chipset;
+
+	hwif->drives[0].autotune = 1;
+	hwif->drives[1].autotune = 1;
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+	/* enable dma of both ide drives */
+	hwif->drives[0].autodma = noautodma ? 0 : 1;
+	hwif->drives[1].autodma = noautodma ? 0 : 1;
+	hwif->rqsize = 256;
+
+	/* we will do autotune at dmacheck time */
+	if (noautodma == 0) {
+		hwif->drives[0].autotune = 0;
+		hwif->drives[1].autotune = 0;
+	}
+
+	/* enable  all  ultra dma  and  multiword  dma operation,  but
+	 * disable single */
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_UDMA
+	hwif->ultra_mask = 0x7f; /* enable UDMA */
+#else
+	hwif->ultra_mask = 0x0; /* disable UDMA */
+#endif
+	hwif->udma_four = 1;
+	hwif->mwdma_mask = 0x07;
+	hwif->swdma_mask = 0x0;
+
+ 	hwif->autodma = 1;
+ 	hwif->atapi_dma = 1;
+
+	/* dma callbacks */
+	hwif->ide_dma_on = tangox_bmide_dma_on;
+	hwif->ide_dma_check = tangox_bmide_dma_check;
+	hwif->ide_dma_off_quietly = tangox_bmide_dma_off_quietly;
+	hwif->ide_dma_host_on = tangox_bmide_dma_host_on;
+	hwif->ide_dma_host_off = tangox_bmide_dma_host_off;
+
+	hwif->ide_dma_test_irq = tangox_bmide_dma_test_irq;
+	hwif->ide_dma_lostirq = tangox_bmide_dma_lostirq;
+	hwif->ide_dma_timeout = tangox_bmide_dma_timeout;
+
+	hwif->dma_setup = tangox_dma_setup;
+	hwif->dma_exec_cmd = tangox_dma_exec_cmd;
+	hwif->dma_start = tangox_dma_start;
+	hwif->ide_dma_end = tangox_bmide_dma_end;
+
+	hwif->dma_command = REG_BASE_host_interface + IDECTRL_bmic;
+	hwif->dma_status = REG_BASE_host_interface + IDECTRL_bmis;
+
+	em86xx_mbus_init();
+#endif
+	return 0;
+}
+
+static void __exit tangox_bmide_exit(void)
+{
+        return;
+}
+
+
+#ifdef MODULE
+module_init(tangox_bmide_init);
+module_exit(tangox_bmide_exit);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SMP86xx BM IDE driver");
+
+#ifdef CONFIG_RUNTIME_CLK_CALC
+/* The following is for runtime calculation of register value based on the mode and given
+ * system frequency by Ivan K. */
+static unsigned int CalcRegValTiming_PIO_DMA(j2_tim_pio_dma_t *t, unsigned long ide_clock)
+{
+	unsigned int dwRet;
+	unsigned int cycle_clks;	// ide clocks / cycle
+	unsigned int active_clks;	// ide clocks for active strobe
+	unsigned int recov_clks;	// ide clocks for recovery
+	unsigned int setup_clks;	// ide clocks for setup
+	unsigned int hold_clks;	// ide clocks for hold
+
+	// pio_timings in ns
+	cycle_clks	= (ide_clock * t->cycle_time)/1000;
+	active_clks	= (ide_clock * t->active_time)/1000;
+	recov_clks	= (ide_clock * t->recovery_time)/1000;
+	setup_clks	= (ide_clock * t->setup_time)/1000;
+	hold_clks	= (ide_clock * t->hold_time)/1000;
+
+	if(cycle_clks>0x7F) {
+		cycle_clks = 0x7F;
+	}
+	
+	if(active_clks>0x3F) {
+		active_clks = 0x3F;
+	}
+
+	if(recov_clks>0x3F) {
+		recov_clks = 0x3F;
+	}
+
+	if(setup_clks>0xF) {
+		setup_clks = 0xF;
+	}
+	
+	if(hold_clks>0x7) {
+		setup_clks = 0x7;
+	}
+	
+	dwRet	= (1<<31) | (cycle_clks<<24) | (active_clks<<16) | (recov_clks<<8) | (setup_clks<<4) | (hold_clks);
+
+	return dwRet;
+}
+
+static unsigned int CalcRegValTiming1_UDMA(j2_tim_udma_t *t, unsigned long ide_clock)
+{
+	unsigned int dwRet;
+	unsigned int t_zah,t_mli,t_ack,t_env,t_rp,t_cyc;
+
+	// pio_timings in ns
+	t_zah	= (ide_clock * t->t_zah)/1000;
+	t_mli	= (ide_clock * t->t_mli)/1000;
+	t_ack	= (ide_clock * t->t_ack)/1000;
+	t_env	= (ide_clock * t->t_env)/1000;
+	t_rp	= (ide_clock * t->t_rp) /1000;
+	t_cyc	= (ide_clock * t->t_cyc)/1000;
+
+	if ( t_zah > 0x0F ) {
+		t_zah = 0x0F;
+	}
+	if ( t_mli > 0x0F ) {
+		t_mli = 0x0F;
+	}
+	if ( t_ack > 0x0F ) {
+		t_ack = 0x0F;
+	}
+	if ( t_env > 0x0F) {
+		t_env = 0x0F;
+	}
+	if ( t_rp > 0x3F ) {
+		t_rp = 0x3F;
+	}
+	if ( t_cyc > 0x3F ) {
+		t_cyc = 0x3F;
+	}
+	
+	dwRet	= (t_zah<<28) | (t_mli<<24) | (t_ack<<20) | (t_env<<16) | (t_rp<<8) | (t_cyc);
+
+	return dwRet;
+}
+
+static unsigned int CalcRegValTiming2_UDMA(j2_tim_udma_t *t, unsigned long ide_clock)
+{
+	unsigned int dwRet;
+	unsigned int t_cvh,t_cvs;
+	
+	// pio_timings in ns
+	t_cvh	= (ide_clock * t->t_cvh)/1000;
+	t_cvs	= (ide_clock * t->t_cvs)/1000;
+
+	if ( t_cvh > 0x03 ) {
+		t_cvh = 0x03;
+	}
+	if ( t_cvs > 0x3F ) {
+		t_cvs = 0x3F;
+	}
+
+	dwRet	= (t_cvh<<8) | (t_cvs);
+
+	return dwRet;
+}
+#endif /* CONFIG_RUNTIME_CLK_CALC */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/tangox-ide.h linux-2.6.15/drivers/ide/tangox/tangox-ide.h
--- linux-2.6.15.ref/drivers/ide/tangox/tangox-ide.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/tangox-ide.h	2008-01-18 17:57:48.000000000 -0800
@@ -0,0 +1,24 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGOX_IDE_H
+#define __TANGOX_IDE_H
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2api.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3api.h>
+#endif
+
+#endif /* __TANGOX_IDE_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/tangox-pbide.c linux-2.6.15/drivers/ide/tangox/tangox-pbide.c
--- linux-2.6.15.ref/drivers/ide/tangox/tangox-pbide.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/tangox-pbide.c	2008-01-18 17:58:46.000000000 -0800
@@ -0,0 +1,548 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/*
+ * driver/ide/tangox/tangox_pbide.c
+ * TANGOX PB IDE driver
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ide.h>
+#include "tangox-ide.h"
+
+extern int tangox_isaide_irq_map(void);
+extern int tangox_isaide_enabled(void);
+extern int tangox_isaide_cs_select(void);
+extern int tangox_isaide_timing_slot(void);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SMP86xx PB IDE driver");
+
+static unsigned long g_regbase_read, g_regbase_write;
+
+/*
+ * io helpers for PIO access
+ */
+static void tangox_pbide_outb(u8 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_pbide_outw(u16 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_pbide_outbsync(ide_drive_t *drive, u8 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static u8 tangox_pbide_inb(unsigned long port)
+{
+	u8 val;
+
+	val = ((u8)(gbus_readw(port) & 0xff));
+	return val;
+}
+
+static u16 tangox_pbide_inw(unsigned long port)
+{
+	u16 val;
+
+	val = ((u16)(gbus_readw(port) & 0xffff));
+	return val;
+}
+
+static void tangox_pbide_insw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		*(u16 *)addr = (u16)(gbus_readw(port) & 0xffff);
+		addr += 2;
+	}
+}
+
+static void tangox_pbide_outsw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		gbus_writew(port, *(u16 *)addr);
+		addr += 2;
+	}
+}
+
+//
+// data structure initialization
+//
+static void tangox_pbide_init_hwif_ports(hw_regs_t *hw, unsigned long data_port, 
+					unsigned long ctrl_port, int *irq)
+{
+	int i;
+	unsigned long reg;
+
+	memset(hw, 0, sizeof(*hw));
+
+	// setup io_ports
+	for (i = IDE_DATA_OFFSET, reg = data_port; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = reg;
+		reg += 4;
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+	hw->dma = NO_DMA;
+
+	if (irq) 
+		*irq = tangox_isaide_irq_map();
+}
+
+/*
+ * tangox_pbide_tune_drive
+ */
+static void tangox_pbide_tune_drive(ide_drive_t *drive, u8 pio)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+
+        if (pio == 255)
+                pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+        hwif->speedproc(drive, pio + XFER_PIO_0);
+}
+
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX_DMA
+static int tangox_pbide_dma_off_quietly(ide_drive_t *drive)
+{
+        drive->using_dma = 0;
+        return 0;
+}
+
+static int tangox_pbide_dma_test_irq(ide_drive_t *drive)
+{
+        return 1;
+}
+
+static void tangox_pbide_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+        /* issue  cmd to  drive,  and register  interrupt handler  for
+         * command completion */
+        //ide_execute_command(drive, command, &ide_dma_intr, (2 * WAIT_CMD), NULL);
+}
+
+static void tangox_pbide_dma_start(ide_drive_t *drive)
+{
+	return;
+}
+
+static int tangox_pbide_dma_lostirq(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_timeout(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_host_on(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_host_off(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_on(ide_drive_t *drive)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+
+        if (hwif->ide_dma_host_on)
+                hwif->ide_dma_host_on(drive);
+
+        printk("IDE: DMA enabled for %s%s\n",
+                drive->media == ide_disk ? "ATA DISK " :
+                (drive->media == ide_cdrom ? "ATAPI CDROM " : ""),
+                drive->name);
+        drive->using_dma = 1;
+        return 0;
+}
+
+/*
+ * Calculate the peripheral bus timing needed for the register used by IDE
+ * devices.
+ */
+
+/* 
+ * The tables bellows use indices as Multi-word DMA 2, Multi-word DMA 1,
+ * Multi-word DMA 0, PIO 4, PIO 3, PIO 2, PIO 1, and PIO 0 (From 0 to 7, 
+ * respectively).
+ */
+
+/* For storing value pair */
+typedef struct {
+	unsigned char x;
+	unsigned char y;
+} value_pair;
+
+/* Table used for calculate Ta and Tb */
+static const value_pair tab_values[] = {
+	{3,0}, {5,0}, {7,2}, {3,0}, {5,0}, {5,0}, {7,2}, {10,4}
+};
+
+/* Table used for calculate Tc */
+static const value_pair tc_values[] = {
+	{13,8}, {19,11}, {60,41}, {10,5}, {12,6}, {14,8}, {17,11}, {23,15}
+};
+
+/* Table used for calculate Td */
+static const value_pair td_values[] = {
+	{1,100}, {1,100}, {3,200}, {1,100}, {1,100}, {1,100}, {3,200}, {5,250}
+};
+
+/* 
+ * Calculate the required timing for setting up peripheral bus timing register.
+ *
+ * Input: sysclk = system clock rate (in MHz)
+ *        mode = IDE mode (0-2: Multiword DMA mode 2-0, 3-7: PIO mode 4-0)
+ * Return: 0 = Error
+ *         else = value for setting up the timing register
+ */
+static unsigned long get_pb_ide_timing(unsigned int sysclk, int mode)
+{
+	unsigned char ta = 0;
+	unsigned char tb = 0;
+	unsigned char tc = 0;
+	unsigned char td = 0;
+	long temp = 0;
+	const value_pair *val_ptr = (const value_pair *)0;
+
+	/* The formula is only effective between 100-240MHz */
+	if ((sysclk < 100) && (sysclk > 240))
+		return(0);
+	else if ((mode < 0) && (mode > 7)) /* Mode index is 0-7 only */
+		return(0);
+
+	/* (x, y) = tab_values[mode] */
+	/* (Ta + Tb) = Temp = (ceiling((sysclk - 100) * x / 140) + y) */
+	/* Ta = ceiling(Temp / 2) */
+	/* Tb = (Temp / 2) */
+	val_ptr = &tab_values[mode];
+	temp = ((sysclk - 100) * val_ptr->x) / 140;
+	if ((temp * 140) < ((sysclk - 100) * val_ptr->x))
+		temp++;
+	temp += val_ptr->y;
+	tb = ta = (unsigned char)((temp >> 1) & 0xff);
+	if (temp & 0x1)
+		ta++;
+
+	/* (x, y) = tc_values[mode] */
+	/* Tc = (ceiling((sysclk - 100) * x / 140) + y) */
+	val_ptr = &tc_values[mode];
+	tc = (unsigned char)(((sysclk - 100) * val_ptr->x) / 140) & 0xff;
+	if ((tc * 140) < ((sysclk - 100) * val_ptr->x))
+		tc++;
+	tc += val_ptr->y;
+
+	/* (x, y) = td_values[mode] */
+	/* Td = ceiling(sysclk + y - 400) * x / y) */
+	val_ptr = &td_values[mode];
+	if ((temp = (sysclk + val_ptr->y) - 400) < 0)
+		td = 0; /* It's possible that Td < 0, so we set it to 0 */
+	else {
+		td = (unsigned char)(((temp * val_ptr->x) / val_ptr->y) & 0xff);
+		if ((td * val_ptr->y) < (temp * val_ptr->x))
+			td++;
+	}
+	return((td << 24) | (tc << 16) | (tb << 8) | ta);
+}
+
+ide_startstop_t tangox_pbide_dma_intr(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq = HWGROUP(drive)->rq;
+
+	hwif->ide_dma_end(drive);
+
+	ide_end_request(drive, 1,rq->nr_sectors);
+
+	return ide_stopped;
+}
+
+static int tangox_pbide_rwdma(ide_drive_t *drive, int read, struct request *rq)
+{
+	unsigned long size = 0;
+	unsigned long addr = 0;
+
+        ide_hwif_t *hwif = HWIF(drive);
+        struct scatterlist *sg = hwif->sg_table;
+
+        dma_map_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+
+	if (hwif->sg_nents > 2) { /* this shouldn't happen since we limited rqsize=16 for now*/
+      		printk("cannot handle multiple transfer yet. sg_nents=0x%x\n", hwif->sg_nents);
+                dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	        return 1;
+	}
+
+	// setup switchbox and wait for its readiness
+        if (em86xx_mbus_alloc_dma(SBOX_IDEFLASH,  1, &g_regbase_read, NULL, 1)) {
+                printk("fail to alloc read dma, fallback to pio.\n");
+		return 1;
+        }
+
+        /* try to setup dma write channel */
+        if (em86xx_mbus_alloc_dma(SBOX_IDEFLASH,  0, &g_regbase_write, NULL, 1)) {
+                printk("fail to alloc write dma, fallback to pio.\n");
+		em86xx_mbus_free_dma(g_regbase_read, SBOX_IDEFLASH);
+		return 1;
+        }
+
+	// setup handler
+	if (drive->media == ide_disk)
+		ide_set_handler(drive, &tangox_pbide_dma_intr, 2 * WAIT_CMD, NULL);
+
+        addr = sg_dma_address(sg);
+       	size = sg_dma_len(sg);
+
+	if (hwif->sg_nents == 1) {
+
+		/* perform a single (linear/rectangle) transfer */
+
+	        // setup PB automode registers
+	        gbus_writel(REG_BASE_host_interface + PB_automode_start_address, 0);
+	        gbus_writel(REG_BASE_host_interface + PB_automode_control,
+				0x00140000 | ((read ? 1 : 0) << 16) | (size >> 1));
+
+	        if (read)
+        	        dma_cache_inv((unsigned int)phys_to_virt(addr), size);
+	        else
+	                dma_cache_wback_inv((unsigned int)phys_to_virt(addr), size);
+
+        	em86xx_mbus_setup_dma(read ? g_regbase_read : g_regbase_write,
+                		addr, size, NULL, NULL, 1);
+	}
+	else { 
+		/* perform a double transfer */
+		unsigned int addr1 = 0;
+		unsigned int size1 = 0;
+
+		sg = &hwif->sg_table[1];
+
+	        addr1 = sg_dma_address(sg);
+	       	size1 = sg_dma_len(sg);
+
+	        // setup PB automode registers
+	        gbus_writel(REG_BASE_host_interface + PB_automode_start_address, 0);
+	        gbus_writel(REG_BASE_host_interface + PB_automode_control,
+				0x00140000 | ((read ? 1 : 0) << 16) | ((size+size1) >> 1));
+
+                if (read) {
+                        dma_cache_inv((unsigned int)phys_to_virt(addr), size);
+                        dma_cache_inv((unsigned int)phys_to_virt(addr1), size1);
+		} else {
+                        dma_cache_wback_inv((unsigned int)phys_to_virt(addr), size);
+                        dma_cache_wback_inv((unsigned int)phys_to_virt(addr1), size1);
+		}
+
+                mbus_setup_dma_double(read ? g_regbase_read : g_regbase_write, 
+				addr, size, addr1, size1, 1);
+	}
+
+	if (drive->media == ide_disk) {
+		// send IDE command
+		HWIF(drive)->OUTB(read ? (drive->addressing ? WIN_READDMA_EXT : WIN_READDMA) : 
+			(drive->addressing ? WIN_WRITEDMA_EXT : WIN_WRITEDMA), IDE_COMMAND_REG);
+	}
+
+	return 0;
+}
+
+static int tangox_pbide_dma_setup(ide_drive_t *drive)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+        struct request *rq;
+        int iswrite;
+
+        drive->waiting_for_dma = 1;
+        rq = HWGROUP(drive)->rq;
+        iswrite = (rq_data_dir(rq) == WRITE);
+        hwif->sg_dma_direction = iswrite ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+	
+	// this will do the merge
+	ide_map_sg(drive, rq);
+
+        return tangox_pbide_rwdma(drive, !iswrite, rq);
+}
+
+static int tangox_ide_config_drive_for_dma(ide_drive_t *drive, int mode)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+        int config_allows_dma = 0;
+        struct hd_driveid *id = drive->id;
+        int speed;
+
+        // enable DMA for CDROM by default
+        if (drive->media == ide_disk || drive->media == ide_cdrom)
+                config_allows_dma = 1;
+
+        if (id && (id->capability & 1) && hwif->autodma && config_allows_dma) {
+                speed = ide_dma_speed(drive, mode);
+
+                /* For CDROM, we do the max. MDMA mode 2 */
+		//if ((speed > XFER_MW_DMA_2) && (drive->media == ide_cdrom))
+		//	speed = XFER_MW_DMA_2;
+
+                if (speed >= XFER_MW_DMA_0) {
+                        if (hwif->speedproc)
+                                hwif->speedproc(drive, speed);
+                        ide_config_drive_speed(drive, speed);
+                        return hwif->ide_dma_on(drive);
+                }
+        }
+
+        return hwif->ide_dma_off_quietly(drive);
+}
+
+static int tangox_pbide_dma_check(ide_drive_t *drive)
+{
+	return tangox_ide_config_drive_for_dma(drive, 0);
+}
+
+static void tangox_pbide_tune_chipset_drive(int drive, int speed, int verbose)
+{
+	extern unsigned long tangox_get_sysclock(void);
+	int mode = speed & 0x0f;
+	unsigned int timing;
+	
+	if (speed >= XFER_PIO_0 && speed <= XFER_PIO_4)
+		mode -= 8;
+	else if (speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2)
+		mode += 5;
+	else
+		return;	
+
+	// get_pb_ide_timing() receives mode in reversed order
+	//   PIO : 7-3
+	//   Multi-word DMA : 2-0
+	mode = 7 - mode;
+	timing = get_pb_ide_timing(tangox_get_sysclock() * 11 / (10*1000000), mode);
+	gbus_writel(REG_BASE_host_interface + PB_timing_slot(tangox_isaide_timing_slot()), timing);
+}
+
+static int tangox_pbide_tune_chipset(ide_drive_t *drive, u8 speed)
+{
+	tangox_pbide_tune_chipset_drive(drive->select.b.unit, speed, 1);
+
+	return ide_config_drive_speed(drive, speed);
+}
+
+static int tangox_pbide_dma_end_io(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct scatterlist *sg = hwif->sg_table;
+	struct request *rq = HWGROUP(drive)->rq;
+
+	int stat = em86xx_mbus_wait(rq->cmd == READ ? g_regbase_read : 
+					g_regbase_write, SBOX_IDEFLASH);
+
+	dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+
+	/* Free up MBUS channel */
+	em86xx_mbus_free_dma(g_regbase_read, SBOX_IDEFLASH);
+	em86xx_mbus_free_dma(g_regbase_write, SBOX_IDEFLASH);
+	return((stat != 0) ? 1 : 0);
+}
+
+static int tangox_pbide_dma_end(ide_drive_t *drive)
+{
+	int status;
+
+	drive->waiting_for_dma = 0;
+	status = tangox_pbide_dma_end_io(drive);
+	return(status);
+}
+#endif
+
+//
+// initialize IDE driver
+//
+int __init tangox_pbide_init(void)
+{
+	int index, i;
+	ide_hwif_t *hwif;
+	hw_regs_t hw;
+#ifdef MODULE
+        ide_drive_t *drive = NULL;
+#endif
+
+	if (tangox_isaide_enabled() == 0)
+		return 0;
+	else
+		tangox_pbide_init_hwif_ports(&hw, 
+			REG_BASE_host_interface_ISAIDE(tangox_isaide_cs_select()), 0, &hw.irq);
+
+       	index = ide_register_hw(&hw, &hwif);
+	printk("%s: SMP863x/SMP865x PB IDE controller.\n", hwif->name);
+
+	// initialize ide_hwifs data structure
+	// supports only one interface
+	for (i = index; i < index + 1; ++i) {
+		// register DMA handler
+		hwif = &ide_hwifs[i];
+
+	        /* set up local I/O function entry points */
+	        hwif->INB = tangox_pbide_inb;
+	        hwif->INW = tangox_pbide_inw;
+	        hwif->INSW = tangox_pbide_insw;
+	        hwif->OUTB = tangox_pbide_outb;
+	        hwif->OUTW = tangox_pbide_outw;
+	        hwif->OUTBSYNC = tangox_pbide_outbsync;
+	        hwif->OUTSW = tangox_pbide_outsw;
+
+		hwif->rqsize = 16; 
+
+	    if (!noautodma) {
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX_DMA 
+		hwif->autodma = 1;
+		hwif->atapi_dma = 1;
+		hwif->ultra_mask = 0x00;	// dpbble all Ultra DMA
+		hwif->mwdma_mask = 0x07;	// enable all Multi-word DMA
+		hwif->swdma_mask = 0x80;	// dpbble all Single-word DMA
+
+	        hwif->dma_setup = tangox_pbide_dma_setup;
+	        hwif->dma_exec_cmd = tangox_pbide_dma_exec_cmd;
+	        hwif->dma_start = tangox_pbide_dma_start;
+		hwif->ide_dma_end = tangox_pbide_dma_end;
+
+		hwif->ide_dma_check = tangox_pbide_dma_check;
+		hwif->ide_dma_on = tangox_pbide_dma_on;
+		hwif->ide_dma_off_quietly = tangox_pbide_dma_off_quietly;
+		hwif->ide_dma_test_irq = tangox_pbide_dma_test_irq;
+		hwif->ide_dma_host_on = tangox_pbide_dma_host_on;
+		hwif->ide_dma_host_off = tangox_pbide_dma_host_off;
+		hwif->ide_dma_lostirq = tangox_pbide_dma_lostirq;
+		hwif->ide_dma_timeout = tangox_pbide_dma_timeout;
+	      	hwif->tuneproc = tangox_pbide_tune_drive;
+		hwif->speedproc = tangox_pbide_tune_chipset;
+#endif
+	    }
+	}
+
+	return 0;
+}
+
+void __exit tangox_pbide_exit(void)
+{
+        return;
+}
+
+#ifdef MODULE
+module_init(tangox_pbide_init);
+module_exit(tangox_pbide_exit);
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/fs/direct-io.c linux-2.6.15/fs/direct-io.c
--- linux-2.6.15.ref/fs/direct-io.c	2006-01-25 20:51:52.000000000 -0800
+++ linux-2.6.15/fs/direct-io.c	2008-01-18 17:57:48.000000000 -0800
@@ -1002,6 +1002,14 @@
 		user_addr = (unsigned long)iov[seg].iov_base;
 		dio->size += bytes = iov[seg].iov_len;
 
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+		if (bytes) {
+			if (rw == WRITE)
+				dma_cache_wback_inv(user_addr, bytes);
+			else
+				dma_cache_inv(user_addr, bytes);
+		}
+#endif
 		/* Index into the first page of the first block */
 		dio->first_block_in_page = (user_addr & ~PAGE_MASK) >> blkbits;
 		dio->final_block_in_request = dio->block_in_file +
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/include/linux/cdrom.h linux-2.6.15/include/linux/cdrom.h
--- linux-2.6.15.ref/include/linux/cdrom.h	2006-01-25 20:52:00.000000000 -0800
+++ linux-2.6.15/include/linux/cdrom.h	2008-01-18 17:57:48.000000000 -0800
@@ -287,6 +287,10 @@
 	unsigned char		data_direction;
 	int			quiet;
 	int			timeout;
+#ifdef CONFIG_SD_CDROM_DMAPACKET
+	int                     do_dma;         /* Try to use DMA */
+	int                     dma_error;      /* A DMA_specific error occurred */
+#endif
 	void			__user *reserved[1];	/* unused, actually */
 };
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/include/linux/ide.h linux-2.6.15/include/linux/ide.h
--- linux-2.6.15.ref/include/linux/ide.h	2006-01-25 20:52:00.000000000 -0800
+++ linux-2.6.15/include/linux/ide.h	2008-01-18 17:57:48.000000000 -0800
@@ -60,7 +60,7 @@
 /*
  * Probably not wise to fiddle with these
  */
-#define ERROR_MAX	8	/* Max read/write errors per sector */
+#define ERROR_MAX	4	/* Max read/write errors per sector */
 #define ERROR_RESET	3	/* Reset controller every 4th retry */
 #define ERROR_RECAL	1	/* Recalibrate every 2nd retry */
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/mm/memory.c linux-2.6.15/mm/memory.c
--- linux-2.6.15.ref/mm/memory.c	2006-01-25 20:52:04.000000000 -0800
+++ linux-2.6.15/mm/memory.c	2008-01-18 17:57:48.000000000 -0800
@@ -965,6 +965,21 @@
 	vm_flags &= force ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);
 	i = 0;
 
+#if defined(CONFIG_MIPS) && defined(CONFIG_DMA_NONCOHERENT)
+	if (len && (current == tsk)) {
+		struct vm_area_struct *vma = find_vma(current->mm, start & PAGE_MASK);
+		if (vma && ((start & PAGE_MASK) >= vma->vm_start) && (((start & PAGE_MASK) + (len << PAGE_SHIFT)) <= vma->vm_end)) {
+			if (write) {
+				if (vma->vm_flags & VM_READ)
+					dma_cache_inv(start & PAGE_MASK, len << PAGE_SHIFT);
+			} else {
+				if (vma->vm_flags & VM_WRITE)
+					dma_cache_wback_inv(start & PAGE_MASK, len << PAGE_SHIFT);
+			}
+		}
+	}
+#endif
+
 	do {
 		struct vm_area_struct *vma;
 		unsigned int foll_flags;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/README.1004.ide.patch linux-2.6.15/README.1004.ide.patch
--- linux-2.6.15.ref/README.1004.ide.patch	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/README.1004.ide.patch	2008-01-18 18:14:43.000000000 -0800
@@ -0,0 +1,21 @@
+Feature:
+--------
+Bus Mastering IDE and PB IDE controllers support for SMP863xx.
+Some common fixes for block device operations are included as well.
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+1003
+
+Primary author:
+---------------
+External (Craig Qu/YH Lin)
+
+Related to which chip version SMP86xx xx=?
+-----------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
