diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/kernel/proc.c linux-2.6.15/arch/mips/kernel/proc.c
--- linux-2.6.15.ref/arch/mips/kernel/proc.c	2006-01-25 20:51:10.000000000 -0800
+++ linux-2.6.15/arch/mips/kernel/proc.c	2008-02-11 19:17:40.000000000 -0800
@@ -111,9 +111,15 @@
 	                            current_cpu_data.cputype : CPU_UNKNOWN],
 	                           (version >> 4) & 0x0f, version & 0x0f,
 	                           (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
+#ifdef CONFIG_TANGOX
+	seq_printf(m, "Initial BogoMIPS\t: %lu.%02lu\n",
+	              cpu_data[n].udelay_val / (500000/HZ),
+	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
+#else
 	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
 	              cpu_data[n].udelay_val / (500000/HZ),
 	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
+#endif
 	seq_printf(m, "wait instruction\t: %s\n", cpu_wait ? "yes" : "no");
 	seq_printf(m, "microsecond timers\t: %s\n",
 	              cpu_has_counter ? "yes" : "no");
@@ -136,6 +142,16 @@
 	seq_printf(m, fmt, 'D', vced_count);
 	seq_printf(m, fmt, 'I', vcei_count);
 
+#ifdef CONFIG_TANGOX
+	{
+		extern unsigned long tangox_get_cpuclock(void);
+		extern unsigned long tangox_get_sysclock(void);
+		extern unsigned long tangox_get_dspclock(void);
+		seq_printf(m, "System bus frequency\t: %ld Hz\n", tangox_get_sysclock());
+		seq_printf(m, "CPU frequency\t\t: %ld Hz\n", tangox_get_cpuclock());
+		seq_printf(m, "DSP frequency\t\t: %ld Hz\n", tangox_get_dspclock());
+	}
+#endif
 	return 0;
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/kernel/time.c linux-2.6.15/arch/mips/kernel/time.c
--- linux-2.6.15.ref/arch/mips/kernel/time.c	2008-02-11 19:16:14.000000000 -0800
+++ linux-2.6.15/arch/mips/kernel/time.c	2008-02-11 19:17:40.000000000 -0800
@@ -46,6 +46,14 @@
 #include <asm/tango3/emhwlib_registers_tango3.h>
 #endif
 
+#ifdef CONFIG_TANGOX
+void reset_timer(unsigned long cpu, unsigned long sys);
+extern unsigned long tangox_get_cpuclock(void);
+extern unsigned long tangox_get_sysclock(void);
+extern unsigned long em8xxx_cpu_frequency;
+extern unsigned long em8xxx_sys_frequency;
+#endif
+
 /*
  * The integer part of the number of usecs per jiffy is taken from tick,
  * but the fractional part is not recorded, so we calculate it using the
@@ -442,6 +450,8 @@
 	static unsigned long old_xtal = 0;
 	long diff;
 	unsigned long xtal;
+  	unsigned long cpu_frequency = tangox_get_cpuclock();
+  	unsigned long sys_frequency = tangox_get_sysclock();
 #endif
 
 	if ((jiffies % HZ) == 0) { /* Update CPU heart beat conunter per second */
@@ -464,6 +474,10 @@
 	} else 
 		active = 1;
 	old_xtal = xtal;
+ 	if ((cpu_frequency != em8xxx_cpu_frequency) || (sys_frequency != em8xxx_sys_frequency)) {
+ 		/* Detected CPU/System frequency change */
+ 		reset_timer(cpu_frequency, sys_frequency);
+ 	}
 #endif
 #endif
 
@@ -820,3 +834,36 @@
 {
 	return (unsigned long long)jiffies*(1000000000/HZ);
 }
+
+#ifdef CONFIG_TANGOX
+/* Called after PLL has been reset */
+void reset_timer(unsigned long cpu_freq, unsigned long sys_freq)
+{
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+	extern void reset_cpu_timer0(void);
+#endif
+	em8xxx_cpu_frequency = cpu_freq;
+	em8xxx_sys_frequency = sys_freq;
+
+	mips_hpt_frequency = em8xxx_cpu_frequency / 2;
+
+	/* Calculate cache parameters.  */
+	cycles_per_jiffy = (mips_hpt_frequency + HZ / 2) / HZ;
+
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+	reset_cpu_timer0();
+#else
+	/* sll32_usecs_per_cycle = 10^6 * 2^32 / mips_counter_freq  */
+	do_div64_32(sll32_usecs_per_cycle,
+			1000000, mips_hpt_frequency / 2,
+			mips_hpt_frequency);
+#endif
+
+	/* Report the high precision timer rate for a reference.  */
+	printk("Using %u.%03u MHz high precision timer.\n",
+			((mips_hpt_frequency + 500) / 1000) / 1000,
+			((mips_hpt_frequency + 500) / 1000) % 1000);
+}
+EXPORT_SYMBOL(reset_timer);
+#endif /* CONFIG_TANGOX */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/pci/pci-tangox.c linux-2.6.15/arch/mips/pci/pci-tangox.c
--- linux-2.6.15.ref/arch/mips/pci/pci-tangox.c	2008-02-11 19:16:16.000000000 -0800
+++ linux-2.6.15/arch/mips/pci/pci-tangox.c	2008-02-11 19:17:40.000000000 -0800
@@ -36,6 +36,8 @@
 #include <asm/tango3/tango3_pci.h>
 #endif
 
+#include <asm/cacheflush.h>
+
 /*
  * computed in prom.c
  */
@@ -407,3 +409,24 @@
 	return 0;
 }
 
+void tangox_pci_enable(void)
+{
+	struct pci_bus *bus = tangox_controller.bus;
+        struct list_head *list;
+
+	if (pci_active) {
+		list_for_each(list, &bus->devices) {
+			pci_set_master(pci_dev_b(list));
+		}
+	}
+}
+
+void tangox_flush_cache_all(void)
+{
+	flush_cache_all();
+}
+
+EXPORT_SYMBOL(tangox_pci_shutdown);
+EXPORT_SYMBOL(tangox_pci_enable);
+EXPORT_SYMBOL(tangox_flush_cache_all);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/fckernel.c linux-2.6.15/arch/mips/tangox/fctrl/fckernel.c
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/fckernel.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/fckernel.c	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,664 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <asm/tlbflush.h>
+
+#include "lib/fc/fcconfig.h"
+#include "lib/freqctrl.h"
+
+#ifdef CONFIG_TANGO2
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <linux/interrupt.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/emhwlib_dram.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/memcfg.h>
+#elif defined(CONFIG_TANGO3)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <linux/interrupt.h>
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/emhwlib_dram.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3api.h>
+#include <asm/tango3/memcfg.h>
+#else
+#error "Unknown architecture"
+#endif
+
+/* The names used in proc_fs */
+#define PROC_ROOT               "tangoxfreq"
+#define PROC_PROFILE            "profile"
+#define PROC_MUX                "mux"
+#define PROC_PLL3               "pll3"
+#define PROC_PLL2               "pll2"
+#define PROC_PLL1               "pll1"
+#define PROC_PLL0               "pll0"
+#define PROC_FREQ               "freq"
+
+#ifdef WITH_INPUT_POLLING
+#define PROC_STANDBY            "standby"
+#ifdef WITH_IR
+#define PROC_IR                 "ir_table"
+#endif
+#ifdef WITH_FIP
+#define PROC_FIP                "fip_table"
+#endif
+#endif
+
+/* Get XENV parameters related to frequency profile */
+extern void tangox_get_ps_config(unsigned long *pll3, unsigned long *pll2, unsigned long *pll1, 
+		unsigned long *pll0, unsigned long *mux, unsigned long *d0cfg, unsigned long *d0delay, 
+		unsigned long *d1cfg, unsigned long *d1delay);
+
+#ifdef WITH_INPUT_POLLING
+extern void tangox_get_standby_config(unsigned long *pll3, unsigned long *pll2, unsigned long *pll1, 
+		unsigned long *pll0, unsigned long *mux, unsigned long *d0cfg, unsigned long *d0delay, 
+		unsigned long *d1cfg, unsigned long *d1delay);
+#endif
+
+extern unsigned long tangox_get_cpuclock(void);
+extern unsigned long tangox_get_sysclock(void);
+extern unsigned long tangox_get_dspclock(void);
+extern unsigned long tangox_get_pllclock(int idx);
+
+static struct freq_profile freq_table[] = {
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "ORIGINAL" }, /* for saving the status when it's been loaded */
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "PS XENV" }, /* for getting the ps status when it's been loaded from XENV */
+	{ 0x0110009e, 0, 0, 0, 0x301, 0xf21111ba, 0x88888, 0xf21111ba, 0x88888, 0, "SYS/CPU/DSP 80/80/80" },  /* SYS/CPU/DSP: 80/80/80MHz, 2/2.5 */
+	{ 0x011000c6, 0, 0, 0, 0x701, 0xf21111ba, 0x97777, 0xf21111ba, 0x97777, 0, "SYS/CPU/DSP 100/150/150" },  /* SYS/CPU/DSP: 150/100/150MHz, 2/2.5 */
+	{ 0x01100108, 0, 0, 0, 0x701, 0xf21111ba, 0x97777, 0xf21111ba, 0x97777, 0, "SYS/CPU/DSP 133/200/200" },  /* SYS/CPU/DSP: 200/133/200MHz, 2/2.5 */
+	{ 0x0110014a, 0, 0, 0, 0x701, 0xf34111ba, 0xa7777, 0xf34111ba, 0xa7777, 0, "SYS/CPU/DSP 166/250/250" },  /* SYS/CPU/DSP: 250/166/250MHz, 3/4 */
+	{ 0x01010041, 0, 0, 0, 0x701, 0xf34111ba, 0xa4444, 0xf34111ba, 0xa4444, 0, "SYS/CPU/DSP 200/300/300" },  /* SYS/CPU/DSP: 300/200/300MHz, 3/4 */
+};
+
+#ifdef WITH_INPUT_POLLING
+static struct freq_profile standby_mode =
+//      { 0x01010010, 0x202, 0x202, 0x202, 0x301, 0xf21111ba, 0x88888, 0xf21111ba, 0x88888, 1, "54/54/54" };  /* CPU/SYS/DSP: 54/54/54MHz, 2/2.5 PLL3 162MHz */
+//	{ 0x0119006a, 0x202, 0x202, 0x202, 0x1, 0xf21111ba, 0x88888, 0xf21111ba, 0x88888, 1, "54/54/54" };  /* CPU/SYS/DSP: 54/54/54MHz, 2/2.5 PLL3 108MHz */
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, "STANDBY XENV" };  /* get the settings from XENV */
+#endif
+
+static int profile_idx = 0;
+static struct proc_dir_entry *root = NULL, *prof_ent = NULL, *mux_ent = NULL, *pll3_ent = NULL;
+static struct proc_dir_entry *pll1_ent = NULL, *pll2_ent = NULL, *pll0_ent = NULL, *freq_ent = NULL;
+
+#ifdef WITH_INPUT_POLLING
+static struct proc_dir_entry *standby_ent;
+#ifdef WITH_IR
+static struct proc_dir_entry *ir_ent = NULL;
+#endif
+#ifdef WITH_FIP
+static struct proc_dir_entry *fip_ent = NULL;
+#endif
+static unsigned long ir_keys[INPUT_TABLE_SIZE/sizeof(unsigned long)];
+static unsigned long fip_keys[INPUT_TABLE_SIZE/sizeof(unsigned long)];
+static int ir_key_cnt, fip_key_cnt;
+#endif
+
+static const unsigned char ratios_table[12][3] = {
+	{ 2, 2, 2 },
+	{ 4, 2, 4 },
+	{ 3, 2, 3 },
+	{ 3, 3, 3 },
+	{ 3, 3, 3 },
+	{ 3, 2, 3 },
+	{ 3, 3, 2 },
+	{ 3, 2, 2 },
+	{ 4, 4, 4 },
+	{ 4, 2, 4 },
+	{ 4, 4, 2 },
+	{ 4, 2, 2 }
+};
+
+static void recalc_frequency(void)
+{
+	extern void tangox_bmide_calc_speed(void);
+	extern void tangox_pbide_calc_speed(void);
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX
+	tangox_bmide_calc_speed();
+#endif
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX
+	tangox_pbide_calc_speed();
+#endif
+
+	/* TODO: may need to re-adjust the CDs */
+}
+
+static int change_profile(const char *str)
+{
+	int prof = simple_strtol(str, NULL, 10);
+	int ret = 0;
+
+	if ((prof < 0) || (prof >= (sizeof(freq_table)/sizeof(struct freq_profile)))) 
+		return -EINVAL;
+
+	for (; prof < sizeof(freq_table)/sizeof(struct freq_profile); prof++) {
+		/* Look for defined profile */
+		if (freq_table[prof].pll3 != 0)
+			break;
+	}
+
+	/* No valid profile found, use original one */
+	if (prof >= (sizeof(freq_table)/sizeof(struct freq_profile)))
+		prof = 0; 
+
+	if (profile_idx == prof)
+		return 0;
+
+	profile_idx = prof;
+
+#ifdef WITH_INPUT_POLLING
+	ret = set_freq_profile(&freq_table[prof], NULL, NULL, NULL, NULL);
+#else
+	ret = set_freq_profile(&freq_table[prof]);
+#endif
+
+	recalc_frequency();
+
+	return ret;
+}
+
+static int change_mux(const char *mux_str)
+{
+	struct freq_profile freq_prof;
+	int mux = simple_strtol(mux_str, NULL, 10);
+	int ret = 0;
+
+	if ((mux < 0) || (mux > 11))
+		return -EINVAL;
+
+	freq_prof.mux = (gbus_readl(REG_BASE_system_block+SYS_sysclk_mux) & 0xfffff0ff) | (mux << 8);
+	freq_prof.d0cfg = gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_cfg);
+	freq_prof.d0delays = gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_delay0_ctrl);
+	freq_prof.d1cfg = gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_cfg);
+	freq_prof.d1delays = gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_delay0_ctrl);
+	freq_prof.pll3 = gbus_readl(REG_BASE_system_block+SYS_clkgen3_pll);
+	freq_prof.pll2 = freq_prof.pll1 = freq_prof.pll0 = 0;
+	freq_prof.standby = 0;
+
+	if (freq_prof.mux != gbus_readl(REG_BASE_system_block+SYS_sysclk_mux))
+		profile_idx = -1;
+
+#ifdef WITH_INPUT_POLLING
+	ret = set_freq_profile(&freq_prof, NULL, NULL, NULL, NULL);
+#else
+	ret = set_freq_profile(&freq_prof);
+#endif
+
+	recalc_frequency();
+
+	return ret;
+}
+
+static int pllx_info_write_proc(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	char buf[64];
+	unsigned long freq;
+	struct freq_profile freq_prof;
+	int idx = (int)data;
+
+	if (count > ARRAY_SIZE(buf) - 1)
+		count = ARRAY_SIZE(buf) - 1;
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	buf[count] = '\0';
+	freq = simple_strtol(buf, NULL, 10);
+
+	freq_prof.mux = gbus_readl(REG_BASE_system_block+SYS_sysclk_mux);
+	freq_prof.d0cfg = gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_cfg);
+	freq_prof.d0delays = gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_delay0_ctrl);
+	freq_prof.d1cfg = gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_cfg);
+	freq_prof.d1delays = gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_delay0_ctrl);
+	freq_prof.standby = 0;
+	freq_prof.pll3 = gbus_readl(REG_BASE_system_block+SYS_clkgen3_pll);
+	freq_prof.pll2 = gbus_readl(REG_BASE_system_block+SYS_clkgen2_pll);
+	freq_prof.pll1 = gbus_readl(REG_BASE_system_block+SYS_clkgen1_pll);
+	freq_prof.pll0 = gbus_readl(REG_BASE_system_block+SYS_clkgen0_pll);
+
+	if (idx == 3) {
+		freq_prof.pll3 = frequency_to_pll(freq, 1);
+	} else if (idx == 2) {
+		freq_prof.pll2 = frequency_to_pll(freq, 1);
+	} else if (idx == 1) {
+		freq_prof.pll1 = frequency_to_pll(freq, 1);
+	} else if (idx == 0) {
+		freq_prof.pll0 = frequency_to_pll(freq, 1);
+	}
+
+	profile_idx = -1;
+#ifdef WITH_INPUT_POLLING
+	set_freq_profile(&freq_prof, NULL, NULL, NULL, NULL);
+#else
+	set_freq_profile(&freq_prof);
+#endif
+
+	recalc_frequency();
+
+	return count;
+}
+
+static int pllx_info_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int ret = 0;
+	int idx = (int)data;
+
+	ret = sprintf(page + off, "PLL%d: %ldHz\n", idx, tangox_get_pllclock(idx));
+	*eof = 1;
+	return ret;
+}
+
+static int freq_info_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int ret = 0;
+	int i;
+	for (i = 0; i < 4; i++) {
+		ret += sprintf(page + off + ret, "PLL%d: %ldHz\n", i, tangox_get_pllclock(i));
+	}
+	ret += sprintf(page + off + ret, "SYS: %ldHz\n", tangox_get_sysclock());
+	ret += sprintf(page + off + ret, "CPU: %ldHz\n", tangox_get_cpuclock());
+	ret += sprintf(page + off + ret, "DSP: %ldHz\n", tangox_get_dspclock());
+	*eof = 1;
+	return ret;
+}
+
+static int profile_info_write_proc(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	char buf[16];
+
+	if (count > ARRAY_SIZE(buf) - 1)
+		count = ARRAY_SIZE(buf) - 1;
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	buf[count] = '\0';
+
+	change_profile(buf);
+
+	return count;
+}
+
+static int profile_info_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int ret = 0;
+	int i;
+
+	for (i = 0; i < (sizeof(freq_table)/sizeof(struct freq_profile)); i++) {
+		if (freq_table[i].pll3 == 0)
+			continue;
+		ret += sprintf(page + off + ret, "%c %d: %s\n", (profile_idx == i) ? '*' : ' ', 
+				i, freq_table[i].desc);
+	}
+	*eof = 1;
+	return ret;
+}
+
+static int mux_info_write_proc(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	char buf[16];
+
+	if (count > ARRAY_SIZE(buf) - 1)
+		count = ARRAY_SIZE(buf) - 1;
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	buf[count] = '\0';
+
+	change_mux(buf);
+
+	return count;
+}
+
+static int mux_info_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int ret = 0, i;
+	unsigned long mux = (gbus_readl(REG_BASE_system_block+SYS_sysclk_mux) >> 8) & 0xf;
+	unsigned long premux = gbus_readl(REG_BASE_system_block+SYS_sysclk_premux);
+	
+	ret = sprintf(page + off, "PLL%ld: %ldHz\n", premux & 3, tangox_get_pllclock(premux & 3));
+	for (i = 0; i < 12; i++) {
+		ret += sprintf(page + off + ret, "%c %d (SYS/CPU/DSP: %d/%d/%d)\n",
+				(i == mux) ? '*' : ' ', i,
+				ratios_table[i][0], ratios_table[i][1], ratios_table[i][2]);
+	}
+	*eof = 1;
+	return ret;
+}
+
+#ifdef WITH_INPUT_POLLING
+static int standby_info_write_proc(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	char buf[16];
+	unsigned long elapse, ret_key;
+	unsigned long *ir_table, *fip_table;
+
+	if (count > ARRAY_SIZE(buf) - 1)
+		count = ARRAY_SIZE(buf) - 1;
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	if (standby_mode.pll3 == 0) { /* not yet setting up */
+		printk("standby mode parameters not set up yet.\n");
+		return -EINVAL;
+	}
+
+	buf[count] = '\0';
+
+#ifdef WITH_IR
+	ir_table = (ir_key_cnt ? ir_keys : NULL);
+#else
+	ir_table = NULL;
+#endif
+#ifdef WITH_FIP
+	fip_table = (fip_key_cnt ? fip_keys : NULL);
+#else
+	fip_table = NULL;
+#endif
+
+	if (strncmp("standby", buf, strlen("standby")) == 0) {
+		printk("Entering standby mode ...\n");
+		set_freq_profile(&standby_mode, &elapse, &ret_key, ir_table, fip_table);
+		jiffies_64 += ((elapse * HZ) / 1000); /* elaspe in msec so we adjust it accordingly */ 
+		printk("Returned key 0x%08lx, time elapse %ld jiffies.\n", ret_key, (elapse * HZ) / 1000);
+	//	recalc_frequency();
+	}
+
+	return count;
+}
+
+#if defined(WITH_IR) || defined(WITH_FIP)
+static const char *hex2string(unsigned long *hex, const char *src_ptr)
+{
+	unsigned long res = 0;
+	const char *src = src_ptr;
+
+	for (; isxdigit(*src); src++) {
+		if (isdigit(*src))
+			res = res * 16 + ((*src) - '0');
+		else
+			res = res * 16 + (__toupper(*src) - 'A' + 10);
+	}
+	*hex = res;
+	return(src);
+}
+
+static const char *dec2string(unsigned long *dec, const char *src_ptr)
+{
+	unsigned long res = 0;
+	const char *src = src_ptr;
+
+	for (; isdigit(*src); src++) {
+		res = res * 10 + ((*src) - '0');
+	}
+	*dec = res;
+	return(src);
+}
+#endif
+
+#ifdef WITH_IR
+static int ir_info_write_proc(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	int i;
+	unsigned long cnt;
+	const char *ptr = buffer, *end = buffer + count;
+
+	memset(ir_keys, 0, INPUT_TABLE_SIZE);
+	ir_key_cnt = 0;
+
+	/* Parse the values */
+	for (cnt = i = 0; (i < INPUT_TABLE_SIZE/sizeof(unsigned long)) && (cnt < count); i++) {
+		for (; (!isdigit(*ptr)) && (ptr < end); ptr++);  /* skip leading unwanted stuff */
+		if (ptr >= end)
+			break; /* no more */
+		else if ((*ptr == '0') && (__toupper(*(ptr + 1)) == 'X')) 
+			ptr = hex2string(&ir_keys[i], ptr + 2);
+		else
+			ptr = dec2string(&ir_keys[i], ptr);
+	}
+	ir_key_cnt = i;
+	return(count);
+}
+
+static int ir_info_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int i, ret = 0;
+	for (i = 0; i < INPUT_TABLE_SIZE/sizeof(unsigned long); i++) {
+		if (ir_keys[i]) 
+			ret += sprintf(page + off + ret, "0x%lx ", ir_keys[i]);
+	}
+	if (ret)
+		ret += sprintf(page + off + ret, "\n");
+	else	
+		ret += sprintf(page + off + ret, "No IR key defined.\n");
+	*eof = 1;
+	return(ret);
+}
+#endif
+#ifdef WITH_FIP
+static int fip_info_write_proc(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	int i;
+	unsigned long cnt;
+	const char *ptr = buffer, *end = buffer + count;
+
+	memset(fip_keys, 0, INPUT_TABLE_SIZE);
+	fip_key_cnt = 0;
+
+	/* Parse the values */
+	for (cnt = i = 0; (i < INPUT_TABLE_SIZE/sizeof(unsigned long)) && (cnt < count); i++) {
+		for (; (!isdigit(*ptr)) && (ptr < end); ptr++);  /* skip leading unwanted stuff */
+		if (ptr >= end)
+			break; /* no more */
+		else if ((*ptr == '0') && (__toupper(*(ptr + 1)) == 'X')) 
+			ptr = hex2string(&fip_keys[i], ptr + 2);
+		else
+			ptr = dec2string(&fip_keys[i], ptr);
+	}
+	fip_key_cnt = i;
+	return(count);
+}
+
+static int fip_info_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int i, ret = 0;
+	for (i = 0; i < INPUT_TABLE_SIZE/sizeof(unsigned long); i++) {
+		if (fip_keys[i]) 
+			ret += sprintf(page + off + ret, "0x%lx ", fip_keys[i]);
+	}
+	if (ret)
+		ret += sprintf(page + off + ret, "\n");
+	else	
+		ret += sprintf(page + off + ret, "No FIP key defined.\n");
+	*eof = 1;
+	return(ret);
+}
+#endif
+#endif
+
+static int tangox_freq_ctrl_init(void) 
+{
+	int i;
+
+#ifdef WITH_INPUT_POLLING
+	memset(ir_keys, 0, INPUT_TABLE_SIZE);
+	memset(fip_keys, 0, INPUT_TABLE_SIZE);
+	ir_key_cnt = fip_key_cnt = 0;
+#endif
+
+	freq_table[0].pll3 = gbus_readl(REG_BASE_system_block+SYS_clkgen3_pll);
+	freq_table[0].pll2 = gbus_readl(REG_BASE_system_block+SYS_clkgen2_pll);
+	freq_table[0].pll1 = gbus_readl(REG_BASE_system_block+SYS_clkgen1_pll);
+	freq_table[0].pll0 = gbus_readl(REG_BASE_system_block+SYS_clkgen0_pll);
+	freq_table[0].mux = gbus_readl(REG_BASE_system_block+SYS_sysclk_mux);
+	freq_table[0].d0cfg = gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_cfg);
+	freq_table[0].d0delays = gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_delay0_ctrl);
+	freq_table[0].d1cfg = gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_cfg);
+	freq_table[0].d1delays = gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_delay0_ctrl);
+
+	tangox_get_ps_config(&freq_table[1].pll3, &freq_table[1].pll2, &freq_table[1].pll1, 
+			&freq_table[1].pll0, &freq_table[1].mux, &freq_table[1].d0cfg, 
+			&freq_table[1].d0delays, &freq_table[1].d1cfg, &freq_table[1].d1delays);
+
+#ifdef WITH_INPUT_POLLING
+	tangox_get_standby_config(&standby_mode.pll3, &standby_mode.pll2, &standby_mode.pll1, 
+			&standby_mode.pll0, &standby_mode.mux, &standby_mode.d0cfg, 
+			&standby_mode.d0delays, &standby_mode.d1cfg, &standby_mode.d1delays);
+#endif
+
+	for (i = 2; i < (sizeof(freq_table)/sizeof(struct freq_profile)); i++) {
+		freq_table[i].d0cfg = (freq_table[i].d0cfg & 0x0fffffff) | (freq_table[0].d0cfg & 0xf0000000);
+		freq_table[i].d1cfg = (freq_table[i].d1cfg & 0x0fffffff) | (freq_table[0].d1cfg & 0xf0000000);
+	}
+
+	if ((root = proc_mkdir(PROC_ROOT, NULL)) == NULL)
+		return -EINVAL;
+
+	if ((prof_ent = create_proc_entry(PROC_PROFILE, S_IRUGO | S_IWUGO, root)) == NULL) 
+		return -EINVAL;
+	else {
+		prof_ent->read_proc = profile_info_read_proc;
+		prof_ent->write_proc = profile_info_write_proc;
+	}
+
+	if ((mux_ent = create_proc_entry(PROC_MUX, S_IRUGO | S_IWUGO, root)) == NULL) 
+		return -EINVAL;
+	else {
+		mux_ent->read_proc = mux_info_read_proc;
+		mux_ent->write_proc = mux_info_write_proc;
+	}
+
+	if ((freq_ent = create_proc_entry(PROC_FREQ, S_IRUGO, root)) == NULL) 
+		return -EINVAL;
+	else {
+		freq_ent->read_proc = freq_info_read_proc;
+	}
+
+	if ((pll3_ent = create_proc_entry(PROC_PLL3, S_IRUGO | S_IWUGO, root)) == NULL) 
+		return -EINVAL;
+	else {
+		pll3_ent->read_proc = pllx_info_read_proc;
+		pll3_ent->write_proc = pllx_info_write_proc;
+		pll3_ent->data = (void *)3;
+	}
+
+	if ((pll2_ent = create_proc_entry(PROC_PLL2, S_IRUGO | S_IWUGO, root)) == NULL) 
+		return -EINVAL;
+	else {
+		pll2_ent->read_proc = pllx_info_read_proc;
+		pll2_ent->write_proc = pllx_info_write_proc;
+		pll2_ent->data = (void *)2;
+	}
+
+	if ((pll1_ent = create_proc_entry(PROC_PLL1, S_IRUGO | S_IWUGO, root)) == NULL) 
+		return -EINVAL;
+	else {
+		pll1_ent->read_proc = pllx_info_read_proc;
+		pll1_ent->write_proc = pllx_info_write_proc;
+		pll1_ent->data = (void *)1;
+	}
+
+	if ((pll0_ent = create_proc_entry(PROC_PLL0, S_IRUGO | S_IWUGO, root)) == NULL) 
+		return -EINVAL;
+	else {
+		pll0_ent->read_proc = pllx_info_read_proc;
+		pll0_ent->write_proc = pllx_info_write_proc;
+		pll0_ent->data = (void *)0;
+	}
+
+#ifdef WITH_INPUT_POLLING
+	if ((standby_ent = create_proc_entry(PROC_STANDBY, S_IWUGO, root)) == NULL) 
+		return -EINVAL;
+	else 
+		standby_ent->write_proc = standby_info_write_proc;
+#ifdef WITH_IR
+	if (tangox_ir_enabled()) {
+		if ((ir_ent = create_proc_entry(PROC_IR, S_IRUGO | S_IWUGO, root)) == NULL) 
+			return -EINVAL;
+		else {	
+			ir_ent->write_proc = ir_info_write_proc;
+			ir_ent->read_proc = ir_info_read_proc;
+		}
+	}
+#endif
+#ifdef WITH_FIP
+	if (tangox_fip_enabled()) {
+		if ((fip_ent = create_proc_entry(PROC_FIP, S_IRUGO | S_IWUGO, root)) == NULL) 
+			return -EINVAL;
+		else {
+			fip_ent->write_proc = fip_info_write_proc;
+			fip_ent->read_proc = fip_info_read_proc;
+		}
+	}
+#endif
+#endif
+
+	printk("tangox frequency scaling module installed");
+#ifdef WITH_INPUT_POLLING
+	printk(", (standby mode supported)");
+#endif
+	printk(".\n");
+	return 0;
+}
+
+static void tangox_freq_ctrl_exit(void) /* Removes module from kernel */
+{
+	if (root) {
+		if (prof_ent)
+			remove_proc_entry(PROC_PROFILE, root);
+		if (mux_ent)
+			remove_proc_entry(PROC_MUX, root);
+		if (pll3_ent)
+			remove_proc_entry(PROC_PLL3, root);
+		if (pll2_ent)
+			remove_proc_entry(PROC_PLL2, root);
+		if (pll1_ent)
+			remove_proc_entry(PROC_PLL1, root);
+		if (pll0_ent)
+			remove_proc_entry(PROC_PLL0, root);
+		if (freq_ent)
+			remove_proc_entry(PROC_FREQ, root);
+#ifdef WITH_INPUT_POLLING
+		if (standby_ent)
+			remove_proc_entry(PROC_STANDBY, root);
+#ifdef WITH_IR
+		if (ir_ent)
+			remove_proc_entry(PROC_IR, root);
+#endif
+#ifdef WITH_FIP
+		if (fip_ent)
+			remove_proc_entry(PROC_FIP, root);
+#endif
+#endif
+		remove_proc_entry(PROC_ROOT, NULL);
+	}
+	printk("tangox: frequency scaling module unloaded.\n");
+}
+
+module_init(tangox_freq_ctrl_init);
+module_exit(tangox_freq_ctrl_exit);
+
+MODULE_DESCRIPTION("SMP863x/SMP865x frequency scaling driver");
+MODULE_AUTHOR("Craig Qu/YH Lin");
+MODULE_LICENSE("GPL");
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/binout.c linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/binout.c
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/binout.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/binout.c	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,42 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/* Utility program to turn a binary file into a C header file */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+static const char *vname = "binout"; /* Default variable name */
+
+int main(int argc, char *argv[])
+{
+	int cnt = 0, fno = 0;
+	unsigned char c;
+
+	if ((fno = open(argv[1], O_RDONLY)) < 0)
+		return(-1);
+	else if ((argc == 3) && (argv[2] != NULL))
+		vname = argv[2];
+
+	printf("static const char %s[] = {\n", vname);
+	
+	while(read(fno, &c, sizeof(unsigned char)) == sizeof(unsigned char)) {
+		if ((cnt > 0) && ((cnt % 16) == 0))
+			printf("\n");
+		printf("0x%02x,", c);
+		cnt++;
+	}
+	printf("};\n");
+
+	close(fno);
+	return(0);
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/eth.c linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/eth.c
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/eth.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/eth.c	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,99 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/config.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#include <asm/tango2/emhwlib_lram.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_dram_tango3.h>
+#include <asm/tango2/emhwlib_lram.h>
+#endif
+
+#define KSEG1ADDR(x)            (0xa0000000|(x))
+
+#define __sync()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		".set	mips2\n\t"		\
+		"sync\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: /* no input */		\
+		: "memory")
+
+#define __fast_iob()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		"lw	$0,%0\n\t"		\
+		"nop\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: "m" (*(int *)0xa0000000)	\
+		: "memory")
+
+#define fast_iob()				\
+	do {					\
+		__sync();			\
+		__fast_iob();			\
+	} while (0)
+
+#define WOL_CTRL   0x602c
+
+extern void uart_putc(const char c);
+extern void uart_puts(const char *s);
+extern void udelay(unsigned usec);
+
+static unsigned long wol_ctrl = 0;
+
+int eth_open(void)
+{
+#ifdef FC_DEBUG
+	uart_puts("Listening for WOL packet.\n");
+#endif
+	wol_ctrl = *((volatile unsigned long *)KSEG1ADDR(REG_BASE_host_interface + WOL_CTRL));
+	*((volatile unsigned long *)KSEG1ADDR(REG_BASE_host_interface + WOL_CTRL)) = 6;
+	fast_iob();
+	return(0);
+}
+
+int eth_close(void)
+{
+	*((volatile unsigned long *)KSEG1ADDR(REG_BASE_host_interface + WOL_CTRL)) = 0x60;
+	fast_iob();
+	*((volatile unsigned long *)KSEG1ADDR(REG_BASE_host_interface + WOL_CTRL)) = wol_ctrl;
+	fast_iob();
+#ifdef FC_DEBUG
+	uart_puts("Stop listening to WOL packet.\n");
+#endif
+	udelay(1000);
+
+	return(0);
+}
+
+unsigned long eth_poll_key(void)
+{
+	unsigned long wol_stat = *((volatile unsigned long *)KSEG1ADDR(REG_BASE_host_interface + WOL_CTRL));
+	if ((wol_stat & 0x60) != 0) {
+		/* clear the status */
+		*((volatile unsigned long *)KSEG1ADDR(REG_BASE_host_interface + WOL_CTRL)) = 0x60;
+		fast_iob();
+#ifdef FC_DEBUG
+		uart_puts("Got WOL packet\n");
+#endif
+		return(1);
+	} else
+		return(0);
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/fc.ld.script linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/fc.ld.script
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/fc.ld.script	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/fc.ld.script	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,59 @@
+OUTPUT_ARCH(mips)
+ENTRY(__frequency_set)
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  .text      :
+  {
+    _ftext = . ;
+    fc.o (.text)		/* entry point		    */
+    *(.text)
+    _ecode = ABSOLUTE(.) ;	/* End of code 			    */
+    *(.rodata)
+    *(.rodata.*)
+    *(.rodata1)
+  } =0
+  _etext = .;
+
+  . = ALIGN(8);
+  _sdata = .;
+
+  .data :
+  AT( _sdata )
+  {
+    _fdata = .;	/* Start of initialised data	    */
+    *(.data)
+   
+    . = ALIGN(8);
+
+    _gp = . + 0x7ff0; /* Base of small data		    */
+
+    *(.lit8) 
+    *(.lit4) 
+    *(.sdata) 
+
+    . = ALIGN(8);
+
+    _edata  = .;	/* End of initialised data	    */
+  }
+
+  _fbss = .;
+  .sbss : 
+  { 
+    *(.sbss) 
+    *(.scommon)
+  }
+  .bss :
+  {
+    *(.bss)
+    *(COMMON)
+  }
+  . = ALIGN(256);
+  _end = . ;
+
+  /* Sections to be discarded */
+  /DISCARD/ :
+  {
+    	*(.reginfo)
+  }
+}
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/fc.S linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/fc.S
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/fc.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/fc.S	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,329 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/* 
+ * Assembly routine to implement the change of frequency
+ */
+
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#include <asm/tango2/emhwlib_lram.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_dram_tango3.h>
+#include <asm/tango2/emhwlib_lram.h>
+#endif
+
+#ifndef INPUT_TABLE_SIZE
+#define INPUT_TABLE_SIZE    32
+#endif
+
+#ifdef WITH_IR
+#define IR_FLAG  1
+#else
+#define IR_FLAG  0
+#endif
+
+#ifdef WITH_FIP
+#define FIP_FLAG  2
+#else
+#define FIP_FLAG  0
+#endif
+
+#ifdef WITH_ETH
+#define ETH_FLAG  4
+#else
+#define ETH_FLAG  0
+#endif
+
+#define KSEG1_ADDR 0xa0000000
+#define DELAY(reg1,reg2,value) \
+		li reg1,value;	\
+		move reg2,zero;	\
+	1: 	bne reg1,reg2,1b;	\
+		addiu reg2,reg2,1;
+
+LEAF(__frequency_set)
+
+	.align	4
+entry_point:
+	.word	_start
+params_start:
+	.word	param_area
+ir_table:
+	.word	ir_keys
+fip_table:
+	.word	fip_keys
+return_key:
+	.word	0
+time_elapse:
+	.word	0
+input_ctrl:
+	.word	(IR_FLAG | FIP_FLAG | ETH_FLAG)
+
+	.align	4
+param_area:
+setting_pll3:
+	.word   0	/* pll3 */
+setting_pll2:
+	.word   0	/* pll2 */
+setting_pll1:
+	.word   0	/* pll1 */
+setting_pll0:
+	.word   0	/* pll0 */
+setting_mux:
+	.word   0	/* mux */
+setting_d0cfg:
+	.word   0	/* d0cfg */
+setting_d0delay:
+	.word   0	/* d0delay */
+setting_d1cfg:
+	.word   0	/* d1cfg */
+setting_d1delay:
+	.word   0	/* d1delay */
+setting_standby:
+	.word	0	/* standby mode */
+setting_desc:
+	.word	0	/* desc */
+
+	.align	4
+ir_keys:
+	.fill	INPUT_TABLE_SIZE
+
+fip_keys:
+	.fill	INPUT_TABLE_SIZE
+
+	/* all cache should be flushed (i.e. written back), interrupt should be disabled at this point */
+	/* a0 = standby mode (or not) */
+
+	.align	5
+	.set noreorder
+	.set mips32r2
+
+old_pll3:
+	.word	0
+old_pll1:
+	.word	0
+old_mux:
+	.word	0
+
+	.align	4
+_start:
+set_dram_auto_refesh:
+	/* set DRAM0/1 to auto-refresh mode */
+	li	t6,KSEG1_ADDR+REG_BASE_dram_controller_0+G2L_RESET_CONTROL
+	li	t4,KSEG1_ADDR+REG_BASE_dram_controller_0+DRAM_dunit_delay0_ctrl
+	li	t7,KSEG1_ADDR+REG_BASE_dram_controller_1+G2L_RESET_CONTROL
+	li	t5,KSEG1_ADDR+REG_BASE_dram_controller_1+DRAM_dunit_delay0_ctrl
+	addiu	t3,zero,1
+	sw	t3,0(t6)
+	sw	t3,0(t7)
+	sync
+
+	move	t3,zero
+	lui	t3,0x8000
+1:
+	lw	t0,0(t4)  /* need the MSB of delay0_ctrl to be set */
+	lw	t1,0(t5)
+	and	t0,t0,t3
+	and	t0,t0,t1
+	beq	t0,zero,1b
+	nop
+
+set_new_freq:
+	/* set CPU/SYS/DSP to new divider value */
+	li	t0,KSEG1_ADDR+REG_BASE_system_block+SYS_sysclk_mux
+	la	t1,setting_mux
+	la	t3,old_mux
+	lw	t2,0(t0)
+	sw	t2,0(t3)
+	lw	t2,0(t1)
+	sw	t2,0(t0)
+	sync
+
+	DELAY	(t3,t2,255)
+
+	/* Detach PLL from MUX, assumed it's been attached before */
+	li	t0,KSEG1_ADDR+REG_BASE_system_block+SYS_sysclk_mux
+	la	t1,setting_mux
+	lw	t2,0(t1)
+	addiu	t2,t2,-1
+	sw	t2,0(t0)
+	sync
+
+	DELAY	(t3,t2,255)
+	
+	/* set PLL3 to new frequency */
+	li	t0,KSEG1_ADDR+REG_BASE_system_block+SYS_clkgen3_pll
+	la	t1,setting_pll3
+	la	t3,old_pll3
+	lw	t2,0(t0)
+	sw	t2,0(t3)
+	lw	t2,0(t1)
+	sw	t2,0(t0)
+	sync
+
+	DELAY	(t3,t2,0x28000)
+
+	/* Re-attach PLL to MUX */
+	li	t0,KSEG1_ADDR+REG_BASE_system_block+SYS_sysclk_mux
+	la	t1,setting_mux
+	lw	t2,0(t1)
+	sw	t2,0(t0)
+	sync
+
+	DELAY	(t3,t2,255)
+
+prepare_for_stand_by:
+	/* We enter stand-by mode in local RAM */
+	/* Setup the stack in local RAM */
+	move	t1,sp
+	li	t0,KSEG1_ADDR+REG_BASE_cpu_block
+	addiu	sp,t0,LR_STACKTOP-16 
+	sw	t1,0(sp)
+	sw	ra,4(sp)
+
+	/* Clear BSS */
+	la	t0,_edata
+	la	t1,_end
+2:	beq	t0,t1,3f
+	nop
+
+	sb	zero,0(t0)
+	j	2b
+	addiu	t0,t0,1
+
+3:
+	/* ready to call entry point */
+	DELAY	(t3,t2,255)
+
+#ifdef WITH_INPUT_POLLING
+
+	/* Check do we need to enter standby mode? */
+	beq	a0,zero,not_standby
+	nop
+
+	/* Yes, we do */
+poll_input:
+	move	v0,zero
+	la	a0,ir_keys
+	la	a1,fip_keys
+	la	a2,input_ctrl
+	la	a3,time_elapse
+	jal	polling_input
+	nop
+
+done_poll:
+	la	t0,return_key
+	sw	v0,0(t0)
+
+resume_old_freq:
+	/* set CPU/SYS/DSP to old divider value */
+	li	t0,KSEG1_ADDR+REG_BASE_system_block+SYS_sysclk_mux
+	la	t1,old_mux
+	lw	t2,0(t1)
+	sw	t2,0(t0)
+	sync
+
+	DELAY	(t3,t2,255)
+
+	/* Detach PLL from MUX, assumed it's been attached before */
+	li	t0,KSEG1_ADDR+REG_BASE_system_block+SYS_sysclk_mux
+	la	t1,old_mux
+	lw	t2,0(t1)
+	addiu	t2,t2,-1
+	sw	t2,0(t0)
+	sync
+
+	DELAY	(t3,t2,255)
+	/* set PLL3 back to old frequency */
+	li	t0,KSEG1_ADDR+REG_BASE_system_block+SYS_clkgen3_pll
+	la	t1,old_pll3
+	lw	t2,0(t1)
+	sw	t2,0(t0)
+	sync
+
+	DELAY	(t3,t2,0x28000)
+
+	/* Re-attach PLL from MUX */
+	li	t0,KSEG1_ADDR+REG_BASE_system_block+SYS_sysclk_mux
+	la	t1,old_mux
+	lw	t2,0(t1)
+	sw	t2,0(t0)
+	sync
+
+	/* Restore stack */
+	li	t0,KSEG1_ADDR+REG_BASE_cpu_block
+	addiu	t1,t0,LR_STACKTOP-16
+	lw	sp,0(t1)
+	lw	ra,4(t1)
+
+	b	unset_dram_auto_refresh
+	nop
+
+not_standby:
+
+#else
+	la	t0,return_key
+	la	t1,time_elapse
+	sw	zero,0(t0)
+	sw	zero,0(t1)
+#endif
+
+	move	v0,zero
+
+	/* Restore stack */
+	li	t0,KSEG1_ADDR+REG_BASE_cpu_block
+	addiu	t1,t0,LR_STACKTOP-16 
+	lw	sp,0(t1)
+	lw	ra,4(t1)
+
+	/* reprogram DRAM0/1 configuration */
+	li	t0,KSEG1_ADDR+REG_BASE_dram_controller_0+DRAM_dunit_cfg
+	li	t1,KSEG1_ADDR+REG_BASE_dram_controller_1+DRAM_dunit_cfg
+
+	la	t2,setting_d0cfg
+	lw	t3,0(t2)
+	sw	t3,0(t0)
+	la	t2,setting_d1cfg
+	lw	t3,0(t2)
+	sw	t3,0(t1)
+
+	la	t2,setting_d0delay
+	lw	t3,0(t2)
+	sw	t3,0(t4)
+	la	t2,setting_d1delay
+	lw	t3,0(t2)
+	sw	t3,0(t5)
+	sync
+
+	DELAY	(t3,t2,255)
+
+	b	unset_dram_auto_refresh
+	nop
+
+unset_dram_auto_refresh:
+	/* bring DRAM0/1 out of auto-refresh mode */
+	sw	zero,0(t6)
+	sw	zero,0(t7)
+	sync
+
+	DELAY	(t3,t2,4096)
+
+done:
+	jr	ra
+	nop
+
+END(__frequency_set)
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/fip.c linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/fip.c
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/fip.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/fip.c	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,500 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/config.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#include <asm/tango2/emhwlib_lram.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_dram_tango3.h>
+#include <asm/tango2/emhwlib_lram.h>
+#endif
+
+#define KSEG1ADDR(x)            (0xa0000000|(x))
+
+#define __sync()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		".set	mips2\n\t"		\
+		"sync\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: /* no input */		\
+		: "memory")
+
+extern void uart_putc(const char c);
+extern void uart_puts(const char *s);
+extern void udelay(unsigned usec);
+
+/* EM86XX */
+#define	FIP_BASE				(REG_BASE_system_block+0x500)
+#define	FIP_COMMAND				0x40
+#define	FIP_DISPLAY_DATA			0x44
+#define	FIP_LED_DATA				0x48
+#define	FIP_KEY_DATA1				0x4c
+#define	FIP_KEY_DATA2				0x50
+#define	FIP_SWITCH_DATA				0x54
+#define FIP_CONFIG				0x58
+#define FIP_INT					0x5c
+
+#define FIP_DIVIDER				27	/* default value */
+#define FIP_BUSY				0x200
+#define FIP_ENABLE				0x400
+
+/* FIP commands							*/
+#define	FIP_CMD_DISP_MODE_08DIGITS_20SEGMENTS		0x00
+#define	FIP_CMD_DISP_MODE_09DIGITS_19SEGMENTS		0x08
+#define	FIP_CMD_DISP_MODE_10DIGITS_18SEGMENTS		0x09
+#define	FIP_CMD_DISP_MODE_11DIGITS_17SEGMENTS		0x0a
+#define	FIP_CMD_DISP_MODE_12DIGITS_16SEGMENTS		0x0b
+#define	FIP_CMD_DISP_MODE_13DIGITS_15SEGMENTS		0x0c
+#define	FIP_CMD_DISP_MODE_14DIGITS_14SEGMENTS		0x0d
+#define	FIP_CMD_DISP_MODE_15DIGITS_13SEGMENTS		0x0e
+#define	FIP_CMD_DISP_MODE_16DIGITS_12SEGMENTS		0x0f
+#define	FIP_CMD_DATA_SET_RW_MODE_WRITE_DISPLAY		0x40
+#define	FIP_CMD_DATA_SET_RW_MODE_WRITE_LED_PORT		0x41
+#define	FIP_CMD_DATA_SET_RW_MODE_READ_KEYS		0x42
+#define	FIP_CMD_DATA_SET_RW_MODE_READ_SWITCHES		0x43
+#define	FIP_CMD_DATA_SET_ADR_MODE_INCREMENT_ADR		0x40
+#define	FIP_CMD_DATA_SET_ADR_MODE_FIXED_ADR		0x44
+#define	FIP_CMD_DATA_SET_OP_MODE_NORMAL_OPERATION	0x40
+#define	FIP_CMD_DATA_SET_OP_MODE_TEST_MODE		0x48
+#define	FIP_CMD_ADR_SETTING				0xC0
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_1_16		0x80
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_2_16		0x81
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_4_16		0x82
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_10_16		0x83
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_11_16		0x84
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_12_16		0x85
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_13_16		0x86
+#define	FIP_CMD_DISP_CTRL_PULSE_WIDTH_14_16		0x87
+#define	FIP_CMD_DISP_CTRL_TURN_DISPLAY_OFF_MASK		0x87
+#define	FIP_CMD_DISP_CTRL_TURN_DISPLAY_ON		0x88
+
+#define FIP_DISPLAY_MODE	0xa
+#define MAX_FIP_RAM		23
+#define NUM_SYMBOLS		23
+#define NUM_CHARACTERS		72
+#define NUM_DIGITS		7
+
+#define L_OFF			-1	//means light is or should be off
+#define FIP_NO_CLEAR		0x0004
+
+/* Valid symbols */
+#define DVD_FIP_ON			0
+#define PLAY_FIP_ON			1
+#define DTS_FIP_ON			2
+#define MP3_FIP_ON			3
+#define DOLBYDIGITAL_FIP_ON		4
+#define MPEG4_FIP_ON			5
+#define PAUSE_FIP_ON			6
+#define DVI_FIP_ON              	7
+#define TWIRL_1_FIP_ON			8
+#define TWIRL_2_FIP_ON			9
+#define TWIRL_3_FIP_ON			10
+#define TWIRL_4_FIP_ON			11
+#define TWIRL_5_FIP_ON			12
+#define TWIRL_6_FIP_ON			13
+#define ALL_FIP_ON			14
+#define REPEAT_FIP_ON			15
+#define COLON_MIN_SEC_FIP_ON		16
+#define R1080_FIP_ON			17
+#define R720_FIP_ON			18
+#define COLON_HOUR_MIN_FIP_ON		19
+#define R480_FIP_ON			20
+#define PAL_FIP_ON			21
+#define NTSC_FIP_ON			22
+
+/* Alignment */
+#define FIP_LEFT		0x0000	/* flags for fip_write_text() */
+#define FIP_CENTER		0x0001
+#define FIP_RIGHT		0x0002
+
+/*
+  14 SEGMENT LCD (EXTENDED CHARACTERS MAP)
+
+     a 
+   -----
+f |\j| /| b 
+  |i\|/k|
+  g-- --h
+e |n/|\l| c
+  |/m| \|
+   -----
+     d   
+*/
+#define DIGIT_L(b7,b6,c,l,m,n,e,d)	((b7 << 7) | (b6 << 6) | (c << 5) | (l << 4) | (m << 3) | (n << 2) | (e << 1) | d)
+#define DIGIT_H(g,h,i,j,k,a,b,f)	((g << 7) | (h << 6) | (i << 5) | (j << 4) | (k << 3) | (a << 2) | (b << 1) | f)
+
+/* sequence must match fipcharacters */
+static const char fipcharactersmap[NUM_CHARACTERS+1] = " +-/0123456789<>ABCDEFGHIJKLMNOPQRSTUVWXYZ\\-abcdefghijklmnopqrstuvwxyz|_";
+
+/* we use the inverted mask for clearing a digit without clearing other things */
+static const char fipcharactermask[2] = {
+	DIGIT_L(1,1,0,0,0,0,0,0), 
+	DIGIT_H(0,0,0,0,0,0,0,0)
+};
+
+/* the format is lower byte, higher byte */
+static const char fipcharacters[NUM_CHARACTERS][2] = {
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(0,0,0,0,0,0,0,0)},	//
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(1,1,0,1,0,0,0,0)},	// +
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// -
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,0,1,0,0,0)},	// /
+
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(0,0,0,0,0,1,1,1)},	// 0
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,1,0,0,0,0)},	// 1
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,1,0)},	// 2
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,1,0)},	// 3
+	{DIGIT_L(0,0,1,0,0,0,0,0), DIGIT_H(1,1,0,0,0,0,1,1)},	// 4
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// 5
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// 6
+	{DIGIT_L(0,0,1,0,0,0,0,0), DIGIT_H(0,0,0,0,0,1,1,0)},	// 7
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,1,1)},	// 8
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,1,1)},	// 9
+
+	{DIGIT_L(0,0,0,1,0,0,0,0), DIGIT_H(0,0,0,0,1,0,0,0)},	// <
+	{DIGIT_L(0,0,0,0,0,1,0,0), DIGIT_H(0,0,0,1,0,0,0,0)},	// >
+
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// A
+	{DIGIT_L(0,0,1,0,1,0,0,1), DIGIT_H(0,1,0,1,0,1,1,0)},	// B
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(0,0,0,0,0,1,0,1)},	// C
+	{DIGIT_L(0,0,1,0,1,0,0,1), DIGIT_H(0,0,0,1,0,1,1,0)},	// D
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// E
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,1,0,0,0,1,0,1)},	// F
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// G
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(1,1,0,0,0,0,1,1)},	// H
+	{DIGIT_L(0,0,0,0,1,0,0,1), DIGIT_H(0,0,0,1,0,1,0,0)},	// I
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(0,0,0,0,0,0,1,0)},	// J
+	{DIGIT_L(0,0,0,1,0,0,1,0), DIGIT_H(1,0,0,0,1,0,0,1)},	// K
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(0,0,0,0,0,0,0,1)},	// L
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(0,0,1,0,1,0,1,1)},	// M
+	{DIGIT_L(0,0,1,1,0,0,1,0), DIGIT_H(0,0,1,0,0,0,1,1)},	// N
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(0,0,0,0,0,1,1,1)},	// O
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// P
+	{DIGIT_L(0,0,1,1,0,0,1,1), DIGIT_H(0,0,0,0,0,1,1,1)},	// Q
+	{DIGIT_L(0,0,0,1,0,0,1,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// R
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// S
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,1,0,1,0,0)},	// T
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(0,0,0,0,0,0,1,1)},	// U
+	{DIGIT_L(0,0,1,1,0,0,0,0), DIGIT_H(0,0,1,0,0,0,1,0)},	// V
+	{DIGIT_L(0,0,1,1,0,1,1,0), DIGIT_H(0,0,0,0,0,0,1,1)},	// W
+	{DIGIT_L(0,0,0,1,0,1,0,0), DIGIT_H(0,0,1,0,1,0,0,0)},	// X
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,1,0,1,0,0,0)},	// Y
+	{DIGIT_L(0,0,0,0,0,1,0,1), DIGIT_H(0,0,0,0,1,1,0,0)},	// Z
+
+	{DIGIT_L(0,0,0,1,0,0,0,0), DIGIT_H(0,0,1,0,0,0,0,0)},	// Slash
+	{DIGIT_L(0,0,0,0,0,0,0,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// -
+
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// a
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,0,1)},	// b
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// c
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,1,0)},	// d
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,1,0,0,0,1,1,1)},	// e
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,0,0,0,0,1,0,1)},	// f
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,1,1)},	// g
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(1,1,0,0,0,0,0,1)},	// h
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,0,0,0,0,0)},	// i
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(0,0,0,0,0,0,0,0)},	// j
+	{DIGIT_L(0,0,0,1,1,0,0,0), DIGIT_H(0,1,0,1,0,0,0,0)},	// k
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(0,0,0,0,0,0,0,1)},	// l
+	{DIGIT_L(0,0,1,0,1,0,1,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// m
+	{DIGIT_L(0,0,1,0,0,0,1,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// n
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// o
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// p
+	{DIGIT_L(0,0,1,0,0,0,0,0), DIGIT_H(1,1,0,0,0,1,1,1)},	// q
+	{DIGIT_L(0,0,0,0,0,0,1,0), DIGIT_H(1,0,0,0,0,0,0,0)},	// r
+	{DIGIT_L(0,0,1,0,0,0,0,1), DIGIT_H(1,1,0,0,0,1,0,1)},	// s
+	{DIGIT_L(0,0,0,0,0,0,1,1), DIGIT_H(1,0,0,0,0,0,0,1)},	// t
+	{DIGIT_L(0,0,1,0,0,0,1,1), DIGIT_H(0,0,0,0,0,0,0,0)},	// u
+	{DIGIT_L(0,0,1,1,0,0,0,0), DIGIT_H(0,0,0,0,0,0,0,0)},	// v
+	{DIGIT_L(0,0,1,1,0,1,1,0), DIGIT_H(0,0,0,0,0,0,0,0)},	// w
+	{DIGIT_L(0,0,0,1,1,0,0,0), DIGIT_H(1,1,0,0,0,0,0,0)},	// x
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,1,1,0,0,0)},	// y
+	{DIGIT_L(0,0,0,0,1,0,0,1), DIGIT_H(1,1,0,0,0,0,0,0)},	// z
+
+	{DIGIT_L(0,0,0,0,1,0,0,0), DIGIT_H(0,0,0,1,0,0,0,0)},	// |
+	{DIGIT_L(0,0,0,0,0,0,0,1), DIGIT_H(0,0,0,0,0,0,0,0)}	// _
+};
+
+/* this array is used to display individual symbols
+   the format is [byte position][bit to turn on] - both zero based */
+static const char fipsymbols[NUM_SYMBOLS][2] = {
+	{0, 0}, 	/* DVD */
+	{0, 1}, 	/* PLAY */
+	{0, 2}, 	/* DTS */
+	{0, 3}, 	/* MP3 */
+	{0, 4}, 	/* DOLBY DIGITAL */
+	{0, 5}, 	/* MPEG4 */
+	{0, 6},		/* PAUSE */
+	{0, 7}, 	/* DVI */
+	{1, 0}, 	/* TWIRL1 */
+	{1, 1}, 	/* TWIRL2 */
+	{1, 2}, 	/* TWIRL3 */
+	{1, 3}, 	/* TWIRL4 */
+	{1, 4}, 	/* TWIRL5 */
+	{1, 5}, 	/* TWIRL6 */
+	{1, 6}, 	/* ALL */
+	{1, 7}, 	/* REPEAT */
+	{9, 6},		/* COLON_MIN_SEC */
+	{9, 7}, 	/* R1080 */
+	{12, 7}, 	/* R720 */
+	{15, 6}, 	/* COLON_HOUR_MIN */
+	{15, 7}, 	/* R480 */
+	{18, 7}, 	/* PAL */
+	{21, 7},	/* NTSC */
+};
+
+/* Default brightness level */
+#define BRIGHTNESS		0x7
+
+static const unsigned long fip_base = (unsigned long)KSEG1ADDR(FIP_BASE);
+static char fipram[MAX_FIP_RAM] = {0};
+static int brightness = BRIGHTNESS;
+
+static void fip_write_reg(unsigned int offset, unsigned int val);
+static unsigned int fip_read_reg(unsigned int offset);
+
+static unsigned long fip_config = 0;
+
+#define ABS(x)  (((x) >= 0) ? (x) : -(x))
+#define DIVIDE_FACTOR       2
+
+static int strlen(const char *str)
+{
+	register int i;
+	for (i = 0; *str != '\0'; i++, str++);
+	return(i);
+}
+
+static void fip_usleep(int usec)
+{
+    unsigned long start, end;
+    start = *((volatile unsigned long *)KSEG1ADDR(REG_BASE_system_block + SYS_xtal_in_cnt));
+    end = start + (usec * 27);
+                                                                                
+    if (end <= start) 
+    	while (*((volatile unsigned long *)KSEG1ADDR(REG_BASE_system_block + SYS_xtal_in_cnt)) > start);
+    while (*((volatile unsigned long *)KSEG1ADDR(REG_BASE_system_block + SYS_xtal_in_cnt)) < end);
+}
+
+static unsigned int fip_read_reg(unsigned int offset)
+{
+	unsigned int val = *((volatile unsigned int *)(fip_base + offset));
+	return(val);
+}
+
+static void fip_write_reg(unsigned int offset, unsigned int val)
+{
+	*((volatile unsigned int *)(fip_base + offset)) = val;
+	__sync();
+}
+
+static int is_fip_busy(void)
+{
+	fip_usleep(10);
+	return((fip_read_reg(FIP_CONFIG) & FIP_BUSY) != 0);
+}
+
+static void fip_wait_ready(void)
+{
+	while (is_fip_busy());
+}
+
+static void fip_user_display(int adr, int data)
+{
+	fip_wait_ready();
+	fip_write_reg(FIP_DISPLAY_DATA, data);
+	fip_write_reg(FIP_COMMAND, FIP_CMD_ADR_SETTING | (adr));
+}
+
+static int fip_display_character(const int position, const char character) 
+{
+	int i, byte1, byte2;
+	unsigned char current_contents0, current_contents1;
+	
+	if ((position < 1) || (position > NUM_DIGITS)) 
+		return(0);
+
+	for (i = 0; i < NUM_CHARACTERS; i++) {
+		if (character == fipcharactersmap[i]) {
+			byte1 = 24 - (3 * position);
+			byte2 = 25 - (3 * position);
+
+			current_contents0 = fipram[byte1];
+			current_contents1 = fipram[byte2];
+
+			/* clear */	
+			fipram[byte1] &= fipcharactermask[0];
+			fipram[byte2] &= fipcharactermask[1];
+			
+			/* set new bits */
+			fipram[byte1] |= fipcharacters[i][0];
+			fipram[byte2] |= fipcharacters[i][1];
+
+			/* display if necessary */
+			if (current_contents0 != fipram[byte1])
+				fip_user_display(byte1, fipram[byte1]);
+			if (current_contents1 != fipram[byte2])
+				fip_user_display(byte2, fipram[byte2]);
+			return(1);
+		}
+	}
+	return(0);
+}
+
+static void fip_clear(void)
+{
+	register int i;
+
+	for (i = 0; i < MAX_FIP_RAM; i++) {
+		fipram[i] = 0;
+		fip_user_display(i, fipram[i]);
+	}
+}
+
+static void fip_display_raw(const int byte, const int bit, const int on) 
+{
+	unsigned char current_contents;
+	current_contents = fipram[byte];
+	if (on != 0)
+		fipram[byte] |= (1 << bit);
+	else
+		fipram[byte] &= ~(1 << bit);
+
+	/* display only if necessary */
+	if (current_contents != fipram[byte])
+		fip_user_display(byte, fipram[byte]);
+}
+
+static void fip_display_symbol(const int symbol, const int on) 
+{
+	if ((symbol < 0) || (symbol >= NUM_SYMBOLS)) 
+		return;
+	fip_display_raw(fipsymbols[symbol][0], fipsymbols[symbol][1], on);
+}
+
+static void fip_write_text(const int position, const char *text, const int flags) 
+{
+	int x, i, j;
+	int textLen = strlen(text);
+
+	if (flags & FIP_CENTER)
+		x = (position > 0) ? position - textLen / 2 : (NUM_DIGITS - textLen) / 2 + 1;
+	else if (flags & FIP_RIGHT)
+		x = (position > 0) ? position - textLen : NUM_DIGITS - textLen + 1;
+	else 
+		x = (position > 0) ? position : 1;
+	if (x < 1) x = 1;
+
+	if ((flags & FIP_NO_CLEAR) == 0) {
+		/* clear colons */
+		fip_display_symbol(COLON_HOUR_MIN_FIP_ON, 0);
+		fip_display_symbol(COLON_MIN_SEC_FIP_ON, 0);
+	}
+
+	/* show/write text */
+	j = 0;
+	for (i = 1; i <= NUM_DIGITS; i++) {
+		if ((i < x) || (i >= (x+textLen)))
+			fip_display_character(i, ' ');
+		else if (!fip_display_character(i, text[j++])) {
+			break;
+		}
+	}
+}
+
+unsigned long fip_poll_key(unsigned long *table, unsigned long size)
+{
+	unsigned long key = 0L;
+
+	fip_wait_ready();
+	fip_write_reg(FIP_COMMAND, FIP_CMD_DATA_SET_RW_MODE_READ_KEYS);
+	fip_wait_ready();
+	key = fip_read_reg(FIP_KEY_DATA1); 
+
+	if ((key == 0) || (table == 0) || (*table == 0)) {
+#ifdef FC_DEBUG
+		if (table == 0)
+			uart_puts("NULL table\n");
+		if (*table == 0)
+			uart_puts("NULL content\n");
+		if (key != 0)
+			uart_puts("Got any FIP key\n");
+#endif
+		return(key);
+	} else {
+		unsigned int i;
+		for (i = 0; i < size; i++, table++) {
+			if (*table == 0)
+				break;
+			else if (key == *table) {
+#ifdef FC_DEBUG
+				uart_puts("Got defined FIP key\n");
+#endif
+				return(key);
+			}
+		}
+		return(0);
+	}
+}
+
+int fip_open(void)
+{
+	unsigned long key = 0L;
+
+#ifdef FC_DEBUG
+	uart_puts("Polling for FIP key.\n");
+#endif
+	fip_config = fip_read_reg(FIP_CONFIG);
+
+	if ((fip_config & FIP_ENABLE) == 0) {
+		fip_write_reg(FIP_CONFIG, (FIP_DIVIDER | FIP_ENABLE));
+		fip_wait_ready();
+
+		/* Clear exisiting IRQ, if any */
+		fip_write_reg(FIP_INT, 0x3);
+		fip_wait_ready();
+
+		/* select display mode */
+		fip_write_reg(FIP_COMMAND, FIP_DISPLAY_MODE);
+		fip_wait_ready();
+
+		/* select brightness of display and turn it on */
+		fip_write_reg(FIP_COMMAND, FIP_CMD_DISP_CTRL_TURN_DISPLAY_ON | brightness);
+		fip_wait_ready();
+
+		/* select write to display and fixed addressing */
+		fip_write_reg(FIP_COMMAND, FIP_CMD_DATA_SET_ADR_MODE_FIXED_ADR);
+		fip_wait_ready();
+
+		fip_clear();
+		fip_write_text(0, "STANDBY", FIP_CENTER);
+
+		/* Flush buffer */
+		while ((key = fip_poll_key(0, 0)) != 0);
+	}
+
+	return(0);
+}
+
+int fip_close(void)
+{
+#ifdef FC_DEBUG
+	uart_puts("Stop polling for FIP key.\n");
+#endif
+	fip_write_reg(FIP_CONFIG, fip_config);
+	udelay(1000);
+	return(0);
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/ir.c linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/ir.c
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/ir.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/ir.c	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,265 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/config.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#include <asm/tango2/emhwlib_lram.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_dram_tango3.h>
+#include <asm/tango2/emhwlib_lram.h>
+#endif
+
+/* For Tango2, it's always there */
+#define WITH_RC5_CONTROL
+#define WITH_RC6_CONTROL
+
+#define SYS_gpio_base           SYS_gpio_dir
+#define KSEG1ADDR(x)            (0xa0000000|(x))
+
+/* NEC Control */
+#define IR_NEC_CTRL             (REG_BASE_system_block + SYS_gpio_base + 0x18)
+#define IR_NEC_CAPTURE_DATA    	(REG_BASE_system_block + SYS_gpio_base + 0x1c)
+#define IR_NEC_CTRL_REGISTER 	((volatile unsigned long *)KSEG1ADDR(IR_NEC_CTRL))
+#define IR_NEC_DATA_REGISTER 	((volatile unsigned long *)KSEG1ADDR(IR_NEC_CAPTURE_DATA))
+
+#ifdef WITH_RC5_CONTROL
+/* RC5 Control */
+#define IR_RC5_CTRL             (REG_BASE_system_block + SYS_gpio_base + 0x20)
+#define IR_RC5_DECODE_CLK_DIV  	(REG_BASE_system_block + SYS_gpio_base + 0x24)
+#define IR_RC5_DECODER_DATA    	(REG_BASE_system_block + SYS_gpio_base + 0x28)
+#define IR_RC5_INT_STATUS    	(REG_BASE_system_block + SYS_gpio_base + 0x2c)
+#define IR_RC5_CTRL_REGISTER 	((volatile unsigned long *)KSEG1ADDR(IR_RC5_CTRL))
+#define IR_RC5_CLK_DIV_REGISTER	((volatile unsigned long *)KSEG1ADDR(IR_RC5_DECODE_CLK_DIV))
+#define IR_RC5_DATA_REGISTER 	((volatile unsigned long *)KSEG1ADDR(IR_RC5_DECODER_DATA))
+#define IR_RC5_INT_STAT_REGISTER ((volatile unsigned long *)KSEG1ADDR(IR_RC5_INT_STATUS))
+#endif /* WITH_RC5_CONTROL */
+
+#ifdef WITH_RC6_CONTROL
+/* RC6 Control */
+#define RC6_DWORDS		5	/* 5 dwords = 20 bytes */
+#define IR_RC6_CTRL             (REG_BASE_system_block + SYS_gpio_base + 0xe0)
+#define IR_RC6_T_CTRL           (REG_BASE_system_block + SYS_gpio_base + 0xe4)
+#define IR_RC6_DATA_OUT0        (REG_BASE_system_block + SYS_gpio_base + 0xe8)
+#define IR_RC6_DATA_OUT1        (REG_BASE_system_block + SYS_gpio_base + 0xec)
+#define IR_RC6_DATA_OUT2        (REG_BASE_system_block + SYS_gpio_base + 0xf0)
+#define IR_RC6_DATA_OUT3        (REG_BASE_system_block + SYS_gpio_base + 0xf4)
+#define IR_RC6_DATA_OUT4        (REG_BASE_system_block + SYS_gpio_base + 0xf8)
+#define IR_RC6_CTRL_REGISTER    ((volatile unsigned long *)KSEG1ADDR(IR_RC6_CTRL))
+#define IR_RC6_T_CTRL_REGISTER  ((volatile unsigned long *)KSEG1ADDR(IR_RC6_T_CTRL))
+#define IR_RC6_DATA0_REGISTER   ((volatile unsigned long *)KSEG1ADDR(IR_RC6_DATA_OUT0))
+#endif
+
+static unsigned long ir_nec_ctrl = 0;
+
+#ifdef WITH_RC5_CONTROL
+static const int rc5_clk_div = 48006;	/* 48006 = 1.778ms, 36018 = 1.334ms, 59994 = 2.222ms */
+static unsigned long ir_rc5_ctrl = 0, old_rc5_clk = 0;
+#endif /* WITH_RC5_CONTROL */
+#ifdef WITH_RC6_CONTROL
+static unsigned long ir_rc6_ctrl = 0, ir_rc6_t_ctrl = 0;
+#endif /* WITH_RC6_CONTROL */
+
+#define __sync()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		".set	mips2\n\t"		\
+		"sync\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: /* no input */		\
+		: "memory")
+
+extern void uart_putc(const char c);
+extern void uart_puts(const char *s);
+extern void udelay(unsigned usec);
+
+/* Produce data */
+unsigned long ir_poll_key(unsigned long *table, unsigned long size)
+{
+	unsigned long status;
+	unsigned long data = 0;
+
+#ifdef WITH_RC6_CONTROL 
+	status = *IR_RC6_CTRL_REGISTER;
+
+	if ((status & 0xc0000000) != 0) {
+		*IR_RC6_CTRL_REGISTER = status;
+#ifdef FC_DEBUG
+		if ((status & 0x40000000) != 0) {
+			uart_puts("RC6 error\n");
+		} 
+#endif
+		if (((status & 0x80000000) != 0) && ((status & 0x40000000) == 0)) {
+			data = *IR_RC6_DATA0_REGISTER | 0x80000000;
+#ifdef WITH_RC5_CONTROL
+			status = *IR_RC5_INT_STAT_REGISTER;
+			if (status & 0x3)
+				*IR_RC5_INT_STAT_REGISTER = status;
+#endif
+			goto got_data;
+		}
+	}
+#endif
+
+#ifdef WITH_RC5_CONTROL
+	status = *IR_RC5_INT_STAT_REGISTER;
+	*IR_RC5_INT_STAT_REGISTER = status;
+	__sync();
+
+	if ((status & 2) != 0) {
+		data = *IR_NEC_DATA_REGISTER;	/* Read from NEC decoder */
+#ifdef FC_DEBUG
+		if (data == 0)
+			uart_puts("NEC error\n");
+#endif
+		if (data != 0)
+			goto got_data;
+	} 
+	if ((status & 1) != 0) {
+		data = *IR_RC5_DATA_REGISTER;
+		if ((data & 0x80000000) != 0) {   /* Invalid RC5 decoder data */
+#ifdef FC_DEBUG
+			uart_puts("RC5 error\n");
+#endif
+			data = 0;
+		}
+		goto got_data;
+	} 
+#else
+	data = *IR_NEC_DATA_REGISTER;
+	__sync();
+	goto got_data;
+#endif
+
+	return(0);
+
+got_data:
+
+	if ((data == 0) || (table == 0) || (*table == 0)) {
+#ifdef FC_DEBUG
+		if (data != 0) 
+			uart_puts("Got IR key\n");
+#endif
+		return(data);
+	} else {
+		unsigned int i;
+		for (i = 0; i < size; i++, table++) {
+			if (*table == 0)
+				break;
+			else if (data == *table) {
+#ifdef FC_DEBUG
+				uart_puts("Got IR key\n");
+#endif
+				return(data);
+			}
+		}
+		return(0);
+	}
+}
+
+/* Open the device */
+int ir_open(void)
+{
+#ifdef FC_DEBUG
+	uart_puts("Polling for IR key.\n");
+#endif
+	ir_nec_ctrl = *IR_NEC_CTRL_REGISTER;
+	*IR_NEC_CTRL_REGISTER = 0;
+#ifdef WITH_RC5_CONTROL
+	ir_rc5_ctrl = *IR_RC5_CTRL_REGISTER;
+	*IR_RC5_CTRL_REGISTER = 0;
+#endif
+#ifdef WITH_RC5_CONTROL
+	ir_rc6_ctrl = *IR_RC6_CTRL_REGISTER;
+	ir_rc6_t_ctrl = *IR_RC6_T_CTRL_REGISTER;
+	*IR_RC6_CTRL_REGISTER = 0xc0000000;
+#endif
+	__sync();
+
+	/* Enable the NEC device (CTRL register) */
+	/*	31:30 - reserved */
+	/*	29:24 	IR_CAPTURE_NBITS [5:0] -> set to 0x1f */
+	/*	23:22 - reserved */
+	/*	21:16 	GPIO_INFREARED_SEL [5:0] -> set to 0x0c */
+	/*	15:14 - reserved */
+	/*	13:0	IR_PREDIV_DEVIDER [13:0] -> set to 0x3b10 */
+	*((volatile unsigned long *)KSEG1ADDR(REG_BASE_system_block + SYS_gpio_dir)) |= ((1 << (16 + 12)));
+	*IR_NEC_CTRL_REGISTER = 0x1f0c3b10;
+
+#ifdef WITH_RC5_CONTROL
+	/* Enable the RC5 device (CTRL register) */
+	/*	31:10 - reserved */
+	/*	9	IR_RC5_INT_ENABLE -> set */
+	/*	8	IR_NEC_INT_DISABLE */
+	/*	7	IR_DEBOUNCE_SEL1 -> set */
+	/*	6	IR_DEBOUNCE_SEL0 -> set */
+	/*	5	IR_DEBOUNCE_ENABLE -> set */
+	/*	4	IR_NEC_DISABLE */
+	/*	3	IR_RSYNC_1/4 -> set */
+	/*	2	IR_RSYNC_1/8 */
+	/*	1	IR_SIGNAL_INVERT */
+	/*	0	IR_DECODE_ENABLE -> set */
+	old_rc5_clk = *IR_RC5_CLK_DIV_REGISTER; 
+	*IR_RC5_CLK_DIV_REGISTER = rc5_clk_div; 
+	*IR_RC5_CTRL_REGISTER = 0x000002e9;
+#endif /* WITH_RC5_CONTROL */
+
+#ifdef WITH_RC6_CONTROL
+	/* Enable the RC6 device (CTRL register) */
+	/*	7	IR_RC6_DATA_IN_INT_ENABLE -> set */
+	/*	6	IR_RC6_ERROR_INT_ENABLE -> set */
+	/*	5:2	reserved */
+	/*	1	IR_SIGNAL_INVERT */
+	/*	0	IR_RC6_DECODE_ENABLE -> set */
+	*IR_RC6_CTRL_REGISTER = 0xc1;
+
+	/* Tolerance and Duration */
+	/*	31:18	Tolerance (typ. 0xbb8) */
+	/*	17:0	Duration (typ. 0x2ee0) */
+	*IR_RC6_T_CTRL_REGISTER = ((0xbb8 << 18) | 0x2ee0);
+#endif
+
+	__sync();
+	return(0);
+}
+
+int ir_close(void)
+{
+#ifdef FC_DEBUG
+	uart_puts("Stop polling for IR key.\n");
+#endif
+	*IR_NEC_CTRL_REGISTER = 0;
+#ifdef WITH_RC5_CONTROL
+	*IR_RC5_CTRL_REGISTER = 0;
+#endif
+#ifdef WITH_RC6_CONTROL
+	*IR_RC6_CTRL_REGISTER = 0xc0000000;
+#endif
+	__sync();
+
+	*IR_NEC_CTRL_REGISTER = ir_nec_ctrl;
+#ifdef WITH_RC5_CONTROL
+	*IR_RC5_CLK_DIV_REGISTER = old_rc5_clk;
+	*IR_RC5_CTRL_REGISTER = ir_rc5_ctrl;
+#endif
+#ifdef WITH_RC6_CONTROL
+	*IR_RC6_CTRL_REGISTER = ir_rc6_ctrl;
+	*IR_RC6_T_CTRL_REGISTER = ir_rc6_t_ctrl;
+#endif /* WITH_RC6_CONTROL */
+
+	__sync();
+	udelay(1000);
+	return(0);
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/Makefile linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/Makefile
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/Makefile	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,158 @@
+
+# Customizations (can be passed down by upper level Makefile)
+# TOP_DIR=/utils/thirdparty/kernelsrc/linux-mips-2.6.15
+# LOCALMEM_BASE=0xa0060010
+# WITH_IR=y
+# WITH_FIP=y
+# WITH_ETH=y
+# FCTRL_DEBUG=y
+# INPUT_TABLE_SIZE=256
+
+# Default header directory
+TOP_DIR ?= $(TOPDIR)
+TOP_DIR ?= /utils/thirdparty/kernelsrc/linux-mips-2.6.15
+
+# Default location for loading/executing the switch handler
+LOCALMEM_BASE ?= 0xa0060010
+
+HOSTCC = gcc
+HOSTCFLAGS = -O2
+
+CROSS = mipsel-linux-
+CC = $(CROSS)gcc
+LD = $(CROSS)ld
+OBJCOPY = $(CROSS)objcopy
+
+CFLAGS = -Wall -Werror -Wstrict-prototypes -Wsign-compare -Os -G 0 -mno-abicalls -fno-pic 
+CFLAGS += -fno-builtin -mabi=32 -march=mips32r2 -Wa,-32 -Wa,-march=mips32r2 -Wa,-mips32r2 -Wa,--trap
+
+# Object files to be used
+FS_OBJS = fc.o
+
+# To include IR polling, optional
+ifeq ($(WITH_IR),y)
+CFLAGS += -DWITH_IR
+FS_OBJS += ir.o
+WITH_INPUT_POLLING = y
+endif
+
+# To include FIP polling, optional
+ifeq ($(WITH_FIP),y)
+CFLAGS += -DWITH_FIP
+FS_OBJS += fip.o
+WITH_INPUT_POLLING = y
+endif
+
+# To include ETH polling, optional
+ifeq ($(WITH_ETH),y)
+CFLAGS += -DWITH_ETH
+FS_OBJS += eth.o
+WITH_INPUT_POLLING = y
+endif
+
+# To poll from given input, result of previous settings
+ifeq ($(WITH_INPUT_POLLING),y)
+INPUT_TABLE_SIZE ?= 256
+CFLAGS += -DWITH_INPUT_POLLING -DINPUT_TABLE_SIZE=$(INPUT_TABLE_SIZE)
+FS_OBJS += poll.o
+endif
+
+# Debug enabled? or not?
+ifeq ($(FCTRL_DEBUG),y)
+CFLAGS += -DFC_DEBUG
+endif
+
+all: fcbin.h fcconfig.h
+
+binout: binout.c
+	@ $(HOSTCC) $(HOSTCFLAGS) -o $@ $<
+
+fc_bin.tmp: fc.bin binout
+	@ ./binout fc.bin > $@
+
+fcbin.h: fc_bin.tmp
+	@echo
+	@echo "**********************************************************"
+	@echo "The following attributes have been defined for this build:"
+	@echo "  Include path:" $(TOP_DIR)/include
+	@echo "#ifndef __FSBIN_H__" > $@
+	@echo "#define __FSBIN_H__" >> $@
+	@echo "  LOCALMEM_BASE is defined as" $(LOCALMEM_BASE)
+ifeq ($(WITH_IR),y)
+	@echo "  WITH_IR is set"
+else
+	@echo "  WITH_IR is not set"
+endif
+ifeq ($(WITH_FIP),y)
+	@echo "  WITH_FIP is set"
+else
+	@echo "  WITH_FIP is not set"
+endif
+ifeq ($(WITH_ETH),y)
+	@echo "  WITH_ETH is set"
+else
+	@echo "  WITH_ETH is not set"
+endif
+ifeq ($(WITH_INPUT_POLLING),y)
+	@echo "  INPUT_POLLING is enabled"
+	@echo "  INPUT_TABLE_SIZE is" $(INPUT_TABLE_SIZE)
+else
+	@echo "  INPUT_POLLING is disabled"
+endif
+	@cat $< >> $@
+	@echo "#endif" >> $@
+	@echo "**********************************************************"
+	@echo
+
+fcconfig.h: Makefile
+	@echo "#ifndef __FSCONFIG_H__" > $@
+	@echo "#define __FSCONFIG_H__" >> $@
+	@echo "#define LOCALMEM_BASE $(LOCALMEM_BASE)" >> $@
+ifeq ($(WITH_IR),y)
+	@echo "#define WITH_IR" >> $@
+else
+	@echo "#undef WITH_IR" >> $@
+endif
+ifeq ($(WITH_FIP),y)
+	@echo "#define WITH_FIP" >> $@
+else
+	@echo "#undef WITH_FIP" >> $@
+endif
+ifeq ($(WITH_ETH),y)
+	@echo "#define WITH_ETH" >> $@
+else
+	@echo "#undef WITH_ETH" >> $@
+endif
+ifeq ($(WITH_INPUT_POLLING),y)
+	@echo "#define WITH_INPUT_POLLING" >> $@
+	@echo "#define INPUT_TABLE_SIZE" $(INPUT_TABLE_SIZE) >> $@
+else
+	@echo "#undef WITH_INPUT_POLLING" >> $@
+	@echo "#undef INPUT_TABLE_SIZE" >> $@
+endif
+	@echo "#endif" >> $@
+
+fc.elf: fc.ld.script $(FS_OBJS)
+	$(LD) -static -T fc.ld.script -Ttext $(LOCALMEM_BASE) -o $@ $(FS_OBJS) 
+
+fc.bin: fc.elf 
+	$(OBJCOPY) -O binary $< $@
+
+fc.o: fc.S Makefile 
+	$(CC) $(CFLAGS) -c -I$(TOP_DIR)/include -D__ASSEMBLY__ -o $@ $<
+
+ir.o: ir.c
+	$(CC) $(CFLAGS) -I$(TOP_DIR)/include -c -o $@ $<
+
+fip.o: fip.c
+	$(CC) $(CFLAGS) -I$(TOP_DIR)/include -c -o $@ $<
+
+eth.o: eth.c
+	$(CC) $(CFLAGS) -I$(TOP_DIR)/include -c -o $@ $<
+
+poll.o: poll.c
+	$(CC) $(CFLAGS) -I$(TOP_DIR)/include -c -o $@ $<
+
+clean:
+	rm -f binout fc_bin.tmp fcbin.h fc.elf fc.bin fc.o fcconfig.h *.o
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/poll.c linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/poll.c
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/fc/poll.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/fc/poll.c	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,178 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/config.h>
+
+#ifdef CONFIG_TANGO2
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#define EM86XX_REVISION 6
+#include <asm/mach-tango2/param.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#include <asm/tango2/emhwlib_lram.h>
+#elif defined(CONFIG_TANGO3)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#define EM86XX_REVISION 1
+#include <asm/mach-tango3/param.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_dram_tango3.h>
+#include <asm/tango2/emhwlib_lram.h>
+#endif
+
+#ifndef KSEG1ADDR
+#define KSEG1ADDR(x)    (0xa0000000|(x))
+#endif
+
+#define UPDATE_XTAL
+
+#ifdef WITH_IR
+int ir_open(void);
+int ir_close(void);
+unsigned long ir_poll_key(unsigned long *table, unsigned long size);
+#endif
+
+#ifdef WITH_FIP
+int fip_open(void);
+int fip_close(void);
+unsigned long fip_poll_key(unsigned long *table, unsigned long size);
+#endif
+
+#ifdef WITH_ETH
+int eth_open(void);
+int eth_close(void);
+unsigned long eth_poll_key(void);
+#endif
+
+#define XTAL_IN       ((volatile unsigned long *)KSEG1ADDR(REG_BASE_system_block+SYS_xtal_in_cnt))
+
+unsigned long polling_input(unsigned long *ir_table, unsigned long *fip_table, 
+	unsigned long *input_ctrl, unsigned long *elapse)
+{
+	unsigned long key = 0;
+	unsigned long table_size = INPUT_TABLE_SIZE / 4;
+#ifdef UPDATE_XTAL
+	const unsigned long inc = TANGOX_BASE_FREQUENCY / 1000; /* elapse in turns of msec */
+	unsigned long old_xtal, new_xtal, diff_xtal;
+
+	*elapse = diff_xtal = 0;
+	old_xtal = new_xtal = (*XTAL_IN);
+#endif
+
+#ifdef WITH_IR
+	if (*input_ctrl & 1)
+		ir_open();
+#endif
+#ifdef WITH_FIP
+	if (*input_ctrl & 2)
+		fip_open();
+#endif
+#ifdef WITH_ETH
+	if (*input_ctrl & 4)
+		eth_open();
+#endif
+
+	while (key == 0) {
+#ifdef WITH_IR
+		if ((key == 0) && (*input_ctrl & 1))
+			key = ir_poll_key(ir_table, table_size);
+#endif
+#ifdef WITH_FIP
+		if ((key == 0) && (*input_ctrl & 2))
+			key = fip_poll_key(fip_table, table_size);
+#endif
+#ifdef WITH_ETH
+		if ((key == 0) && (*input_ctrl & 4))
+			key = eth_poll_key();
+#endif
+#ifdef UPDATE_XTAL
+		new_xtal = (*XTAL_IN);
+		if (new_xtal >= old_xtal) 
+			diff_xtal += (new_xtal-old_xtal);
+		else 
+			diff_xtal += ((0xffffffff-old_xtal)+new_xtal);
+		if (diff_xtal >= inc) {
+			*elapse += (diff_xtal / inc);
+			diff_xtal %= inc;
+		}
+		old_xtal = new_xtal;
+#endif
+	}
+
+#ifdef WITH_ETH
+	if (*input_ctrl & 4)
+		eth_close();
+#endif
+#ifdef WITH_FIP
+	if (*input_ctrl & 2)
+		fip_close();
+#endif
+#ifdef WITH_IR
+	if (*input_ctrl & 1)
+		ir_close();
+#endif
+
+#ifdef UPDATE_XTAL
+	new_xtal = (*XTAL_IN);
+	if (new_xtal >= old_xtal) 
+		diff_xtal += (new_xtal-old_xtal);
+	else 
+		diff_xtal += ((0xffffffff-old_xtal)+new_xtal);
+	if (diff_xtal >= inc) {
+		*elapse += (diff_xtal / inc);
+		diff_xtal %= inc;
+	}
+#endif
+
+	return(key);
+}
+
+#ifdef FC_DEBUG
+
+static const unsigned long cpu_uart_base = REG_BASE_cpu_block + CPU_UART0_base;
+
+void uart_putc(const char c)
+{
+	if (c != '\n') {
+		while (((*(volatile unsigned long *)KSEG1ADDR(cpu_uart_base+CPU_UART_LSR))& 0x20) == 0);
+		*(volatile unsigned long *)KSEG1ADDR(cpu_uart_base+CPU_UART_THR) = (unsigned long)c;
+	} else {
+		while (((*(volatile unsigned long *)KSEG1ADDR(cpu_uart_base+CPU_UART_LSR))& 0x20) == 0);
+		*(volatile unsigned long *)KSEG1ADDR(cpu_uart_base+CPU_UART_THR) = 0x0d;
+		while (((*(volatile unsigned long *)KSEG1ADDR(cpu_uart_base+CPU_UART_LSR))& 0x20) == 0);
+		*(volatile unsigned long *)KSEG1ADDR(cpu_uart_base+CPU_UART_THR) = 0x0a;
+	}
+}
+
+void uart_puts(const char *s)
+{
+	for (; s && (*s != '\0'); s++)
+		uart_putc(*s);
+}
+#endif
+
+static inline unsigned long __getxtal(void)
+{
+	return *((volatile unsigned long *)KSEG1ADDR(REG_BASE_system_block + SYS_xtal_in_cnt));
+}
+
+void udelay(unsigned usec)
+{
+	/* SYS_xtal_in_cnt is a counter running off 27MHz, so 1 usec
+           is roughly equivalent to 27 increase of count */
+	unsigned long start = __getxtal();
+	unsigned long end = start + (usec * 27);
+
+	if (end <= start) 
+		/* Handle overflow condition */
+		while (__getxtal() > start);
+	while (__getxtal() < end);
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/freqctrl.c linux-2.6.15/arch/mips/tangox/fctrl/lib/freqctrl.c
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/freqctrl.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/freqctrl.c	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,388 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ *
+ */
+
+#include "platform.h"
+#include "freqctrl.h"
+
+#include "fc/fcconfig.h"
+#include "fc/fcbin.h"
+
+#ifndef LOCALMEM_BASE
+#error Anchor of handler need to be set
+#endif
+
+static unsigned long localmem[8096/4]; /* Up to 8KB */
+
+struct engine_status
+{
+	unsigned long hb_addr;
+	unsigned long suspend_addr;
+	unsigned long hb;
+	int active;
+	int g2l_status;
+	unsigned long g2lc_addr;
+	const char *desc;
+};
+
+static struct engine_status engines[] = {
+	{ REG_BASE_cpu_block + LR_HB_MPEG0, REG_BASE_cpu_block + LR_SUSPEND_ACK_MPEG0, 0, 0, 0, REG_BASE_mpeg_engine_0 + G2L_RESET_CONTROL, "MPEG0" },
+	{ REG_BASE_cpu_block + LR_HB_MPEG1, REG_BASE_cpu_block + LR_SUSPEND_ACK_MPEG1, 0, 0, 0, REG_BASE_mpeg_engine_1 + G2L_RESET_CONTROL, "MPEG1" },
+	{ REG_BASE_cpu_block + LR_HB_AUDIO0, REG_BASE_cpu_block + LR_SUSPEND_ACK_AUDIO0, 0, 0, 0, REG_BASE_audio_engine_0 + G2L_RESET_CONTROL, "AUDIO0" },
+	{ REG_BASE_cpu_block + LR_HB_AUDIO1, REG_BASE_cpu_block + LR_SUSPEND_ACK_AUDIO1, 0, 0, 0, REG_BASE_audio_engine_1 + G2L_RESET_CONTROL, "AUDIO1" },
+#ifdef CONFIG_TANGO2
+	{ REG_BASE_cpu_block + LR_HB_DEMUX, REG_BASE_cpu_block + LR_SUSPEND_ACK_DEMUX, 0, 0, 0, REG_BASE_demux_engine + G2L_RESET_CONTROL, "DEMUX" },
+#else /* for TANGO3 */
+	{ REG_BASE_cpu_block + LR_HB_DEMUX, REG_BASE_cpu_block + LR_SUSPEND_ACK_DEMUX, 0, 0, 0, REG_BASE_demux_engine_0 + G2L_RESET_CONTROL, "DEMUX0" },
+#if 0
+#warning TANGO3 TODO
+	/* Definitions? */
+	{ REG_BASE_cpu_block + LR_HB_DEMUX1, REG_BASE_cpu_block + LR_SUSPEND_ACK_DEMUX1, 0, 0, 0, REG_BASE_demux_engine_1 + G2L_RESET_CONTROL, "DEMUX1" },
+#endif
+#endif
+	{ REG_BASE_cpu_block + LR_HB_IH, REG_BASE_cpu_block + LR_SUSPEND_ACK_IH, 0, 0, 0, 0, "IH" },
+};
+
+#define SUSPEND_FLAG     1
+#define RESUME_FLAG      0
+#define MAX_DELTA        2700000 /* 100ms */
+#define HB_MONITOR_TIME  100000  /* 100ms */
+
+static unsigned long xtal_delta(unsigned long start, unsigned long end)
+{
+	return (end > start) ? (end - start) : (0xffffffff - start + end + 1);
+}
+
+/* Suspend all engines */
+static void suspend_engines(void)
+{
+	const int num_engines = sizeof(engines) / sizeof(struct engine_status);
+	unsigned long start, end, delta;
+	int i;
+
+	/* First determine which engine is running */
+	for (i = 0; i < num_engines; i++) {
+		engines[i].hb = tangox_gbus_readl(engines[i].hb_addr);
+		if (engines[i].g2lc_addr != 0) /* update block status */
+			engines[i].g2l_status = tangox_gbus_readl(engines[i].g2lc_addr);
+	}
+
+	tangox_udelay(HB_MONITOR_TIME); /* Wait for heartbeat update */
+
+	/* Mark the active flag associate to each engine */
+	for (i = 0; i < num_engines; i++) 
+		engines[i].active = ((engines[i].hb != tangox_gbus_readl(engines[i].hb_addr)) ? 1 : 0);
+
+	/* Start suspend */
+	tangox_gbus_writel(REG_BASE_cpu_block + LR_DRAM_DMA_SUSPEND, SUSPEND_FLAG);
+
+	/* Check all engines to be suspended */
+	for (i = 0; i < num_engines; i++) {
+		if (engines[i].active) {
+			DBG_PRINT("Waiting for %s to be suspended.\n", engines[i].desc);
+			for (delta = 0, start = tangox_gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt); 
+					tangox_gbus_readl(engines[i].suspend_addr) != SUSPEND_FLAG; ) {
+				end = tangox_gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt); 
+				delta = xtal_delta(start, end);
+				if (delta > MAX_DELTA)
+					break;
+			}
+			if (delta <= MAX_DELTA)
+				DBG_PRINT("%s is suspended.\n", engines[i].desc);
+			else
+				DBG_PRINT("Wait for %s timeout.\n", engines[i].desc);
+		} else {
+			DBG_PRINT("%s is not active.\n", engines[i].desc);
+		}
+		if ((engines[i].g2lc_addr != 0) && (engines[i].g2l_status == 0)) /* currently running */
+			tangox_gbus_writel(engines[i].g2lc_addr, 1); /* pause the block */
+	}
+}
+
+/* Resume all engines */
+static void resume_engines(void)
+{
+	const int num_engines = sizeof(engines) / sizeof(struct engine_status);
+	int i;
+	unsigned long start, end, delta;
+
+	for (i = num_engines - 1; i >= 0; i--) {
+		if ((engines[i].g2lc_addr != 0) && (engines[i].g2l_status == 0)) /* used to be running */
+			tangox_gbus_writel(engines[i].g2lc_addr, 0); /* undo pause */
+	}
+
+	/* Start resume */
+	tangox_gbus_writel(REG_BASE_cpu_block + LR_DRAM_DMA_SUSPEND, RESUME_FLAG);
+
+	/* Check all engines to be suspended, in reversed order */
+	for (i = num_engines - 1; i >= 0; i--) {
+		if (engines[i].active) {
+			DBG_PRINT("Waiting for %s to be resumed.\n", engines[i].desc);
+			for (delta = 0, start = tangox_gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt); 
+					tangox_gbus_readl(engines[i].suspend_addr) == SUSPEND_FLAG; ) {
+				end = tangox_gbus_readl(REG_BASE_system_block + SYS_xtal_in_cnt); 
+				delta = xtal_delta(start, end);
+				if (delta > MAX_DELTA)
+					break;
+			}
+			if (delta <= MAX_DELTA)
+				DBG_PRINT("%s is resumed.\n", engines[i].desc);
+			else
+				DBG_PRINT("Wait for %s timeout.\n", engines[i].desc);
+		}
+	}
+}
+
+/* Set to a given frequency profile */
+#ifdef WITH_INPUT_POLLING
+int set_freq_profile(const struct freq_profile *pptr, unsigned long *elapse, unsigned long *ret_key, unsigned long *ir_keys, unsigned long *fip_keys)
+#else
+int set_freq_profile(const struct freq_profile *pptr)
+#endif
+{
+	unsigned long v_cr, v_ier, v_sr;
+	unsigned long ehci_cmd, ohci_ctl;
+	unsigned long flags, ret, old_pll2, old_pll1, old_pll0;
+	int standby = 0;
+	struct freq_handler_header *fs_hdr = (struct freq_handler_header *)(LOCALMEM_BASE+0x20);
+
+#ifdef WITH_INPUT_POLLING
+	if (elapse)
+		*elapse = 0;
+	if (ret_key)
+		*ret_key = 0;
+#endif
+
+	if (pptr->pll3 == 0)
+		return -EINVAL;
+	standby = pptr->standby;
+
+	DBG_PRINT("TangoX Frequency Control\n");
+	DBG_PRINT("Installing handler to 0x%08x, size 0x%x.\n", LOCALMEM_BASE, sizeof(binout));
+
+	/* Save localmem content first */
+	memcpy(localmem, (void *)(LOCALMEM_BASE), sizeof(binout));
+	memcpy((void *)(LOCALMEM_BASE), &binout[0], sizeof(binout));
+
+	suspend_engines();
+
+	DBG_PRINT("Stopping PCI bus artitration...\n");
+	tangox_gbus_writel(REG_BASE_host_interface + PCI_host_reg4, 1);
+
+	DBG_PRINT("Stoping TangoX ethernet...\n");
+	v_cr = tangox_gbus_readl(ENET_DMA_CR);
+	v_ier = tangox_gbus_readl(ENET_DMA_IER);
+	v_sr = tangox_gbus_readl(ENET_DMA_SR);
+	tangox_gbus_writel(ENET_DMA_CR, 0);
+        tangox_gbus_writel(ENET_DMA_IER, 0);
+        tangox_gbus_writel(ENET_DMA_SR, tangox_gbus_readl(ENET_DMA_SR));
+
+	DBG_PRINT("Stopping TangoX EHCI\n");
+        ehci_cmd = tangox_gbus_readl(EHCI_CMD);
+        ehci_cmd &= ~CMD_RUN;
+        tangox_gbus_writel(EHCI_CMD, ehci_cmd);
+
+	DBG_PRINT("Stopping TangoX OHCI\n");
+	ohci_ctl = tangox_gbus_readl(OHCI_CONTROL);
+	tangox_gbus_writel(OHCI_CONTROL, ohci_ctl | HCCONTROL_HCFS);
+	tangox_gbus_writel(OHCI_INT_DISABLE, OHCI_INTR_MIE);
+	tangox_usdelay(16*125); /*need to wait 16*125us*/
+
+	DBG_PRINT("Original config:\n");
+	DBG_PRINT(" PLL3: 0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen3_pll)); 
+	DBG_PRINT(" PLL2: 0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen2_pll)); 
+	DBG_PRINT(" PLL1: 0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen1_pll)); 
+	DBG_PRINT(" PLL0: 0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen0_pll)); 
+	DBG_PRINT(" MUX:  0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_sysclk_mux)); 
+	DBG_PRINT(" D0_CFG: 0x%08lx\n", tangox_gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_cfg));
+	DBG_PRINT(" D0_DELAY: 0x%08lx\n", tangox_gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_delay0_ctrl));
+	DBG_PRINT(" D1_CFG: 0x%08lx\n", tangox_gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_cfg));
+	DBG_PRINT(" D1_DELAY: 0x%08lx\n", tangox_gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_delay0_ctrl));
+
+	old_pll2 = tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen2_pll);
+	if (pptr->pll2) {
+		/* Change PLL2 if needed */
+		DBG_PRINT("Change PLL2 from 0x%08lx to 0x%08lx\n", old_pll2, pptr->pll2);
+		tangox_gbus_writel(REG_BASE_system_block+SYS_clkgen2_pll, pptr->pll2);
+	}
+	old_pll1 = tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen1_pll);
+	if (pptr->pll1) {
+		/* Change PLL1 if needed */
+		DBG_PRINT("Change PLL1 from 0x%08lx to 0x%08lx\n", old_pll1, pptr->pll1);
+		tangox_gbus_writel(REG_BASE_system_block+SYS_clkgen1_pll, pptr->pll1);
+	}
+	old_pll0 = tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen0_pll);
+	if (pptr->pll0) {
+		/* Change PLL0 if needed */
+		DBG_PRINT("Change PLL0 from 0x%08lx to 0x%08lx\n", old_pll0, pptr->pll0);
+		tangox_gbus_writel(REG_BASE_system_block+SYS_clkgen0_pll, pptr->pll0);
+	}
+	tangox_usdelay(10);
+
+	DBG_PRINT("Saving to data 0x%08x\n", (unsigned int)fs_hdr->param_area);
+	memcpy((void *)fs_hdr->param_area, pptr, sizeof(*pptr));
+
+#ifdef WITH_INPUT_POLLING
+	DBG_PRINT("IR table at 0x%08lx, FIP table at 0x%08lx\n", (unsigned long)fs_hdr->ir_table, (unsigned long)fs_hdr->fip_table);
+
+	/* Clear the input table first */
+	memset(fs_hdr->ir_table, 0, INPUT_TABLE_SIZE);
+	memset(fs_hdr->fip_table, 0, INPUT_TABLE_SIZE);
+
+	if (tangox_ir_enabled() && (ir_keys != NULL)) {
+		memcpy(fs_hdr->ir_table, ir_keys, INPUT_TABLE_SIZE);
+		DBG_PRINT("Setting up IR table\n");
+	}
+	if (tangox_fip_enabled() && (fip_keys != NULL)) {
+		memcpy(fs_hdr->fip_table, fip_keys, INPUT_TABLE_SIZE);
+		DBG_PRINT("Setting up FIP table\n");
+	}
+
+	/* From XENV or other means, determine which input is available */
+	fs_hdr->input_ctrl = 0;
+	fs_hdr->input_ctrl |= (tangox_ir_enabled() ? 1 : 0);
+	fs_hdr->input_ctrl |= (tangox_fip_enabled() ? 2 : 0);
+	fs_hdr->input_ctrl |= (tangox_ethernet_enabled() ? 4 : 0);
+
+	DBG_PRINT("Polling ctrl: %ld\n", fs_hdr->input_ctrl);
+#endif
+
+	DBG_PRINT("Disable interrupts, doing frequency adjustment\n");
+
+#ifdef WITH_INPUT_POLLING
+	if (standby)
+		DBG_PRINT("Ready to enter stand-by mode at 0x%08x to %s\n", (unsigned int)fs_hdr->func_ptr, pptr->desc);
+	else
+		DBG_PRINT("Calling handler at 0x%08x\n", (unsigned int)fs_hdr->func_ptr);
+#else
+	DBG_PRINT("Calling handler at 0x%08x\n", (unsigned int)fs_hdr->func_ptr);
+#endif
+
+	tangox_save_flags(flags);
+	tangox_flush_cache_all();
+
+	ret = (*(fs_hdr->func_ptr))(standby);
+
+#ifdef WITH_INPUT_POLLING
+	if (elapse)
+		*elapse = fs_hdr->elapse;
+	if (ret_key)
+		*ret_key = fs_hdr->ret_key;
+#endif
+
+	/* restore localmem content */
+	memcpy((void *)(LOCALMEM_BASE), localmem, sizeof(binout));
+	tangox_restore_flags(flags);
+
+#ifdef WITH_INPUT_POLLING
+	DBG_PRINT("\nReturning from standly mode.\n");
+	if (standby) {
+		if ((pptr->pll2) && (old_pll2 != tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen2_pll))) {
+			DBG_PRINT("Restoring PLL2: 0x%08lx\n", old_pll2);
+			tangox_gbus_writel(REG_BASE_system_block+SYS_clkgen2_pll, old_pll2);
+		}
+		if ((pptr->pll1) && (old_pll1 != tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen1_pll))) {
+			DBG_PRINT("Restoring PLL1: 0x%08lx\n", old_pll1);
+			tangox_gbus_writel(REG_BASE_system_block+SYS_clkgen1_pll, old_pll1);
+		}
+		if ((pptr->pll0) && (old_pll0 != tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen0_pll))) {
+			DBG_PRINT("Restoring PLL0: 0x%08lx\n", old_pll0);
+			tangox_gbus_writel(REG_BASE_system_block+SYS_clkgen0_pll, old_pll0);
+		}
+		tangox_usdelay(10);
+	}
+#else
+	DBG_PRINT("\nReturning from handler.\n");
+#endif
+
+	DBG_PRINT("Re-enable TangoX OHCI\n");
+	tangox_gbus_writel(OHCI_CONTROL, ohci_ctl);
+	tangox_gbus_writel(OHCI_INT_ENABLE, OHCI_INTR_MIE);
+
+	DBG_PRINT("Re-enable TangoX EHCI\n");
+        ehci_cmd |= CMD_RUN;
+        tangox_gbus_writel(EHCI_CMD, ehci_cmd);
+
+	DBG_PRINT("Re-enable TangoX ethernet\n");
+	tangox_gbus_writel(ENET_DMA_CR, v_cr);
+        tangox_gbus_writel(ENET_DMA_IER, v_ier);
+        tangox_gbus_writel(ENET_DMA_SR, v_sr);
+
+	DBG_PRINT("Re-starting PCI bus artitration...\n");
+	tangox_gbus_writel(REG_BASE_host_interface + PCI_host_reg4, 0);
+
+#ifdef WITH_INPUT_POLLING
+	/* Re-calibrate system timing */
+	tangox_reset_timer(tangox_get_cpuclock(), tangox_get_sysclock());
+#endif
+
+	DBG_PRINT("NEW config:\n");
+	DBG_PRINT(" PLL3: 0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen3_pll)); 
+	DBG_PRINT(" PLL2: 0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen2_pll)); 
+	DBG_PRINT(" PLL1: 0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen1_pll)); 
+	DBG_PRINT(" PLL0: 0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_clkgen0_pll)); 
+	DBG_PRINT(" MUX:  0x%08lx\n", tangox_gbus_readl(REG_BASE_system_block+SYS_sysclk_mux)); 
+	DBG_PRINT(" D0_CFG: 0x%08lx\n", tangox_gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_cfg));
+	DBG_PRINT(" D0_DELAY: 0x%08lx\n", tangox_gbus_readl(REG_BASE_dram_controller_0+DRAM_dunit_delay0_ctrl));
+	DBG_PRINT(" D1_CFG: 0x%08lx\n", tangox_gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_cfg));
+	DBG_PRINT(" D1_DELAY: 0x%08lx\n", tangox_gbus_readl(REG_BASE_dram_controller_1+DRAM_dunit_delay0_ctrl));
+
+	DBG_PRINT("NEW CPU frequency: %ldHz\n", tangox_get_cpuclock());
+	DBG_PRINT("NEW SYS frequency: %ldHz\n", tangox_get_sysclock());
+	DBG_PRINT("NEW DSP frequency: %ldHz\n", tangox_get_dspclock());
+
+	/* Resume the engines */
+	resume_engines();
+
+	return 0;
+}
+
+/* Calculate the sys_clkgen_pll value for certain frequency */
+/* freq = desired frequency, ratio = 1 (for PLL), 2-4 (for CPU/SYS/DSP) */
+unsigned long frequency_to_pll(unsigned int freq, unsigned int ratio) 
+{
+	unsigned int m, n;
+	unsigned long pll = 0;
+  
+	if ((freq < 255) && (ratio != 4)) {
+		// Frequency given in MHz. Use Intermediate Freq of 0.5MHz
+		// !! Impossible if ratio=4.
+		m = 54 / ratio; 
+		n = freq * 2; 
+		pll = 0x1000000 + ((m - 2) << 16) + (n - 2);
+	} else {
+		if (freq < 255) 
+			freq *= 1000000;
+		// Frequency in Hz. Find closest match (Try for all M's)
+		unsigned int best_n, best_m, best_f, tmp;
+		best_f = 1000000000;
+		best_m = 0;
+		best_n = 0;
+		for (m = 65; m > 2; m--) {
+			n =((freq / 1000) * m * ratio + 13500) / 27000;
+			if ((n <= 513) && (n >= 2)) {
+				tmp = (TANGOX_BASE_FREQUENCY / (m*ratio)) * n;
+				if (tmp < freq) 
+					tmp = 2 * freq - tmp;
+				if (tmp <= best_f) {
+					best_f = tmp; 
+					best_m = m; 
+					best_n = n;
+				}
+			}
+		}
+		if (best_m != 0)
+			pll = 0x1000000 + ((best_m - 2) << 16) + (best_n - 2);
+	}
+	return(pll);
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/freqctrl.h linux-2.6.15/arch/mips/tangox/fctrl/lib/freqctrl.h
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/freqctrl.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/freqctrl.h	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,144 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __FREQCTRL_H__
+#define __FREQCTRL_H__
+
+#ifndef __FSCONFIG_H__
+#include "fc/fcconfig.h"
+#endif
+
+/* USB related registers */
+#define EHCI_CMD           (REG_BASE_host_interface+0x1410)
+#define OHCI_INTR_MIE      (1<<31)
+#define OHCI_INT_ENABLE    (REG_BASE_host_interface+0x1510)
+#define OHCI_INT_DISABLE   (REG_BASE_host_interface+0x1514)
+#define OHCI_CONTROL       (REG_BASE_host_interface+0x1504)
+#define HCCONTROL_HCFS     (3<<6)
+#define HCCONTROL_USB_OPER (2<<6)
+#define CMD_RUN            (1<<0)
+
+/*
+ * Mac/DMA registers offset, refer to documentation
+ */
+#define ENET_HOST_BASE		REG_BASE_host_interface
+
+/* mac registers */
+#define ENET_MAC_BASE		(ENET_HOST_BASE + 0x6000)
+#define ENET_MAC_MACCR		(ENET_MAC_BASE + 0x0)
+#define MACCR_F			(1 << 20)
+#define MACCR_PM		(1 << 19)
+#define MACCR_PR		(1 << 18)
+#define MACCR_HP		(1 << 13)
+#define MACCR_ASTP		(1 << 8)
+#define MACCR_TE		(1 << 3)
+#define MACCR_RE		(1 << 2)
+#define ENET_MAC_MACAHR		(ENET_MAC_BASE + 0x4)
+#define ENET_MAC_MACALR		(ENET_MAC_BASE + 0x8)
+#define ENET_MAC_MAHR		(ENET_MAC_BASE + 0xc)
+#define ENET_MAC_MALR		(ENET_MAC_BASE + 0x10)
+#define ENET_MAC_MIIAR		(ENET_MAC_BASE + 0x14)
+#define MIIAR_ADDR(x)		((x) << 11)
+#define MIIAR_REG(x)		((x) << 6)
+#define MIIAR_WRITE		(1 << 1)
+#define MIIAR_BUSY		(1 << 0)
+#define ENET_MAC_MIIDR		(ENET_MAC_BASE + 0x18)
+#define ENET_MAC_FCR		(ENET_MAC_BASE + 0x1c)
+#define FCR_ENABLE		(1 << 1)
+
+/* dma registers */
+#define ENET_DMA_BASE		(ENET_HOST_BASE + 0x7000)
+#define ENET_DMA_BMR		(ENET_DMA_BASE + 0x00)
+#define BMR_PBL(x)		((x & 0x3f) << 8)
+#define BMR_SWR			(1 << 0)
+#define ENET_DMA_TPDR		(ENET_DMA_BASE + 0x04)
+#define ENET_DMA_RPDR		(ENET_DMA_BASE + 0x08)
+#define ENET_DMA_RBAR		(ENET_DMA_BASE + 0x0c)
+#define ENET_DMA_TBAR		(ENET_DMA_BASE + 0x10)
+#define ENET_DMA_SR		(ENET_DMA_BASE + 0x14)
+#define SR_EB(x)		(((x) >> 23) & 0x3)
+#define SR_TS(x)		(((x) >> 20) & 0x7)
+#define SR_RS(x)		(((x) >> 17) & 0x7)
+#define SR_NIS			(1 << 16)
+#define SR_AIS			(1 << 15)
+#define SR_ERI			(1 << 14)
+#define SR_FBE			(1 << 13)
+#define SR_ETI			(1 << 12)
+#define SR_RWT			(1 << 11)
+#define SR_RPS			(1 << 8)
+#define SR_RU			(1 << 7)
+#define SR_R			(1 << 6)
+#define SR_UNF			(1 << 5)
+#define SR_TU			(1 << 4)
+#define SR_TPS			(1 << 1)
+#define SR_T			(1 << 0)
+#define ENET_DMA_CR		(ENET_DMA_BASE + 0x18)
+#define CR_SF			(1 << 21)
+#define CR_ST			(1 << 13)
+#define CR_SR			(1 << 1)
+#define ENET_DMA_IER		(ENET_DMA_BASE + 0x1c)
+#define IER_NIS			(1 << 16)
+#define IER_AIS			(1 << 15)
+#define IER_ERE			(1 << 14)
+#define IER_FBE			(1 << 13)
+#define IER_ETE			(1 << 10)
+#define IER_RWT			(1 << 9)
+#define IER_RS			(1 << 8)
+#define IER_RU			(1 << 7)
+#define IER_R			(1 << 6)
+#define IER_UE			(1 << 5)
+#define IER_TBU			(1 << 2)
+#define IER_TS			(1 << 1)
+#define IER_T			(1 << 0)
+#define ENET_DMA_CHRBA		(ENET_DMA_BASE + 0x54)
+
+typedef unsigned long (*FUNC_PTR)(int);
+
+/* Profile for frequency to be switched to */
+struct freq_profile
+{
+	unsigned long pll3;      /* setting for PLL3 */
+	unsigned long pll2;      /* setting for PLL2 */
+	unsigned long pll1;      /* setting for PLL1 */
+	unsigned long pll0;      /* setting for PLL0 */
+	unsigned long mux;       /* sysclk_mux */
+	unsigned long d0cfg;     /* DRAM0 parameters */
+	unsigned long d0delays;
+	unsigned long d1cfg;     /* DRAM1 parameters */
+	unsigned long d1delays;
+	unsigned long standby;   /* standby invocation? */
+	const char *desc;        /* description */
+};
+
+/* For communicating with handler */
+struct freq_handler_header
+{
+	FUNC_PTR func_ptr;      /* Entry point of handler */
+	void *param_area;       /* parameter area */
+#ifdef WITH_INPUT_POLLING
+	void *ir_table;         /* Key filters for IR (standby) */
+	void *fip_table;        /* Key filters for FIP (standby) */
+	unsigned long ret_key;  /* Returned key */
+	unsigned long elapse;   /* Time elapse in standby */
+	unsigned long input_ctrl; /* Which input is enabled */
+#endif
+};
+
+/* Prototyping */
+#ifdef WITH_INPUT_POLLING
+int set_freq_profile(const struct freq_profile *pptr, unsigned long *elapse, unsigned long *ret_key,
+		unsigned long *ir_keys, unsigned long *fip_keys);
+#else
+int set_freq_profile(const struct freq_profile *pptr);
+#endif
+
+unsigned long frequency_to_pll(unsigned int freq, unsigned int ratio);
+
+#endif /* __FREQCTRL_H__ */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/Makefile linux-2.6.15/arch/mips/tangox/fctrl/lib/Makefile
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/Makefile	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,57 @@
+
+TOP_DIR ?= $(TOPDIR)
+MUM_KI  ?= -I/utils/thirdparty/kernelsrc/linux-mips-2.6.15/include
+TOP_DIR ?= $(subst /include,,$(subst -I,,$(MUM_KI)))
+TOP_DIR 	?= $(subst /include,,$(subst -I,,$(MUM_KI)))
+TOP_DIR 	?= /utils/thirdparty/kernelsrc/linux-mips-2.6.15
+
+include $(TOP_DIR)/.config
+
+LOCALMEM_BASE	?= 0xa0060010
+WITH_IR		?= $(CONFIG_TANGOX_STANDBY_WAKEUP_IR)
+WITH_FIP	?= $(CONFIG_TANGOX_STANDBY_WAKEUP_FIP)
+WITH_ETH	?= $(CONFIG_TANGOX_STANDBY_WAKEUP_ETH)
+INPUT_TABLE_SIZE?= $(CONFIG_TANGOX_STANDBY_INPUT_TABLE_SIZE)
+WITH_IR		?= n
+WITH_FIP	?= n
+WITH_ETH	?= n
+INPUT_TABLE_SIZE?= 128
+
+FCTRL_DEBUG     ?= y
+
+CROSS = mipsel-linux-
+CC = $(CROSS)gcc
+LD = $(CROSS)ld
+AR = $(CROSS)ar
+OBJCOPY = $(CROSS)objcopy
+
+FCDIR = fc
+CFLAGS = -Wall -Werror -Wstrict-prototypes -Wsign-compare -O2 -G 0 -mno-abicalls -fno-pic 
+CFLAGS += -fno-builtin -mabi=32 -march=mips32r2 -Wa,-32 -Wa,-march=mips32r2 -Wa,-mips32r2 -Wa,--trap
+CFLAGS += -I$(TOP_DIR)/include -I$(TOP_DIR)/include/asm-mips/mach-tango2 -I$(TOP_DIR)/include/asm-mips/mach-generic
+ifdef CONFIG_TANGO2
+CFLAGS += -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2 -DEM86XX_REVISION=6 -DCONFIG_TANGO2
+else
+CFLAGS += -DEM86XX_CHIP=EM86XX_CHIPID_TANGO3 -DEM86XX_REVISION=1 -DCONFIG_TANGO3
+endif
+CFLAGS += -I$(FCDIR)
+
+ifeq ($(FCTRL_DEBUG),y)
+CFLAGS += -DFC_DEBUG
+endif
+
+all: freqctrl.a
+
+freqctrl.a: freqctrl.o
+	$(AR) rcs $@ $<
+
+$(FCDIR)/fcconfig.h $(FCDIR)/fcbin.h: Makefile
+	$(MAKE) -C $(FCDIR) TOP_DIR=$(TOP_DIR) LOCALMEM_BASE=$(LOCALMEM_BASE) WITH_IR=$(WITH_IR) WITH_FIP=$(WITH_FIP) WITH_ETH=$(WITH_ETH) INPUT_TABLE_SIZE=$(INPUT_TABLE_SIZE) FCTRL_DEBUG=$(FCTRL_DEBUG) 
+
+freqctrl.o: freqctrl.c freqctrl.h $(FCDIR)/fcconfig.h $(FCDIR)/fcbin.h Makefile
+	$(CC) $(CFLAGS) -D__KERNEL__ -c -o $@ freqctrl.c
+
+clean:
+	$(MAKE) -C $(FCDIR) clean
+	rm -f freqctrl.a freqctrl.o
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/platform.h linux-2.6.15/arch/mips/tangox/fctrl/lib/platform.h
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/lib/platform.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/lib/platform.h	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,97 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. All Rights Reserved
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __LINUX_PLATFORM_H__
+#define __LINUX_PLATFORM_H__
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <asm/tlbflush.h>
+
+#ifdef CONFIG_TANGO2
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/emhwlib_dram.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/memcfg.h>
+#elif defined(CONFIG_TANGO3)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/emhwlib_dram.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3api.h>
+#include <asm/tango3/memcfg.h>
+#else
+#error "Unknown architecture"
+#endif
+
+/* Flush all cache */
+extern void tangox_flush_cache_all(void);
+
+/* Reset OS timer */
+extern void reset_timer(unsigned long cpu_freq, unsigned long sys_freq);
+
+/* Get CPU frequency */
+extern unsigned long tangox_get_cpuclock(void);
+
+/* Get SYS frequency */
+extern unsigned long tangox_get_sysclock(void);
+
+/* Get DSP frequency */
+extern unsigned long tangox_get_dspclock(void);
+
+/* Devices */
+extern int tangox_ir_enabled(void);
+extern int tangox_fip_enabled(void);
+extern int tangox_ethernet_enabled(void);
+
+static inline void tangox_gbus_writel(unsigned long addr, unsigned long val)
+{
+	gbus_writel(addr, val);
+}
+
+static inline unsigned long tangox_gbus_readl(unsigned long addr)
+{
+	return gbus_readl(addr);
+}
+
+/* Sleep for given micro-seconds */
+static inline void tangox_usdelay(unsigned long usec)
+{
+	udelay(usec);
+}
+
+/* Re-calibrate OS level timer */
+static inline void tangox_reset_timer(unsigned long cpufreq, unsigned long sysfreq)
+{
+	reset_timer(cpufreq, sysfreq);
+}
+
+/* Disable interrupts and save the flags */
+#define tangox_save_flags(x)      local_irq_save(x)
+
+/* Restore the flags (re-enable interrupt) */
+#define tangox_restore_flags(x)   local_irq_restore(x)
+
+/* For debugging purpose */
+#ifdef FC_DEBUG
+#define DBG_PRINT           printk
+#else
+#define DBG_PRINT(x, ...)
+#endif
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/fctrl/Makefile linux-2.6.15/arch/mips/tangox/fctrl/Makefile
--- linux-2.6.15.ref/arch/mips/tangox/fctrl/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/fctrl/Makefile	2008-02-11 19:17:40.000000000 -0800
@@ -0,0 +1,50 @@
+
+NOTINKERNEL = n
+
+ifneq ($(NOTINKERNEL),y)
+TOP_DIR ?= $(TOPDIR)
+endif
+
+MUM_KI  ?= -I/utils/thirdparty/kernelsrc/linux-mips-2.6.15/include
+TOP_DIR ?= $(subst /include,,$(subst -I,,$(MUM_KI)))
+
+# More parameters to be configured
+ifeq ($(NOTINKERNEL),y)
+WITH_IR		?= n
+WITH_FIP	?= n
+WITH_ETH        ?= n
+INPUT_TABLE_SIZE?= 64
+endif
+
+# For debugging purpose
+FCTRL_DEBUG     ?= y
+
+ifeq ($(FCTRL_DEBUG),y)
+CFLAGS += -DFC_DEBUG
+endif
+
+ifeq ($(NOTINKERNEL),y)
+obj-m := fctrl.o
+else
+obj-$(CONFIG_TANGOX_FREQUENCY_CONTROL) := fctrl.o
+endif
+
+fctrl-objs := fckernel.o lib/freqctrl.o
+
+.PHONY: all
+all: fctrl.ko
+
+lib/freqctrl.o:
+	$(MAKE) -C lib WITH_IR=$(WITH_IR) WITH_FIP=$(WITH_FIP) WITH_ETH=$(WITH_ETH) INPUT_TABLE_SIZE=$(INPUT_TABLE_SIZE) FCTRL_DEBUG=$(FCTRL_DEBUG) TOP_DIR=$(TOP_DIR) CONFIG_TANGO2=$(CONFIG_TANGO2)
+
+fctrl.ko: FORCE lib/freqctrl.o
+	KBUILD_VERBOSE=1 $(MAKE) -C $(TOP_DIR) M="$$PWD" modules
+
+.PHONY: cleanall clean
+cleanall clean:
+	$(MAKE) -C lib clean
+	KBUILD_VERBOSE=1 $(MAKE) -C $(TOP_DIR) M="$$PWD" clean
+
+.PHONY: FORCE
+FORCE:
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/Kconfig linux-2.6.15/arch/mips/tangox/Kconfig
--- linux-2.6.15.ref/arch/mips/tangox/Kconfig	2008-02-11 19:16:14.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/Kconfig	2008-02-11 19:17:40.000000000 -0800
@@ -134,6 +134,53 @@
 	help
 	 System frequency.
 
+config TANGOX_FREQUENCY_CONTROL
+	tristate "Allow dynamic frequency control"
+	depends on (TANGO2_SMP863X || TANGO3_SMP865X) && !TANGOX_FIXED_FREQUENCIES
+	default y if TANGO2_SMP863X
+	default n if TANGO3_SMP865X
+	help
+	 To enable frequency control (under /proc/tangoxfreq) as well as
+	 standby mode support.
+
+config TANGOX_STANDBY_SUPPORT
+	bool "Standby mode support for SMP86xx (Experimental)"
+	depends on TANGOX_FREQUENCY_CONTROL
+	default n
+	help
+	 To enable standby mode support (suspend on RAM). At least one of the input 
+	 mechanism (IR, FIP, built-in ethernet) needs to enable to wake up the 
+	 system. To trigger standby mode, "echo standby > /proc/tangoxfreq/standby".
+
+config TANGOX_STANDBY_WAKEUP_IR
+	bool "Wake up from standby mode via IR"
+	depends on TANGOX_STANDBY_SUPPORT
+	default y
+	help
+	 Support system wake up by IR.
+
+config TANGOX_STANDBY_WAKEUP_FIP
+	bool "Wake up from standby mode via FIP"
+	depends on TANGOX_STANDBY_SUPPORT
+	default y
+	help
+	 Support system wake up by FIP.
+
+config TANGOX_STANDBY_WAKEUP_ETH
+	bool "Wake up from standby mode via built-in ethernet"
+	depends on TANGOX_STANDBY_SUPPORT
+	default y
+	help
+	 Support system wake up by WOL (Wakeup-On-LAN) with magic packet.
+
+config TANGOX_STANDBY_INPUT_TABLE_SIZE
+	int "The size of the filter table, needs to be multiple of 4's"
+	depends on TANGOX_STANDBY_WAKEUP_IR || TANGOX_STANDBY_WAKEUP_FIP
+	default 128
+	help
+	 The filter table to be used to filter the input so only the ones are 
+	 allowed as wake up event.
+
 config TANGOX_USE_CPU_CLOCK
 	bool "Use internal cpu clock for system timer"
 	depends on TANGO2_SMP863X || TANGO3_SMP865X
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/Makefile linux-2.6.15/arch/mips/tangox/Makefile
--- linux-2.6.15.ref/arch/mips/tangox/Makefile	2008-02-11 19:16:20.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/Makefile	2008-02-11 19:17:40.000000000 -0800
@@ -6,6 +6,10 @@
 # unless it's something special (ie not a .c file).
 #
 
+ifneq ($(CONFIG_TANGOX_FREQUENCY_CONTROL),)
+FC_MADE := $(shell $(MAKE) -C $(TOPDIR)/arch/mips/tangox/fctrl/lib TOP_DIR=$(TOPDIR) WITH_IR=$(CONFIG_TANGOX_STANDBY_WAKEUP_IR) WITH_FIP=$(CONFIG_TANGOX_STANDBY_WAKEUP_FIP) WITH_ETH=$(CONFIG_TANGOX_STANDBY_WAKEUP_ETH) INPUT_TABLE_SIZE=$(CONFIG_TANGOX_STANDBY_INPUT_TABLE_SIZE) )
+endif
+
 obj-y += irq.o setup.o prom.o gbus.o tangoxIRQ.o xenv_config.o delay.o
 
 obj-$(CONFIG_TANGOX_PROM_CONSOLE) += console.o
@@ -16,3 +20,7 @@
 
 obj-y += mbus.o
 
+obj-$(CONFIG_TANGOX_FREQUENCY_CONTROL) += fctrl/
+
+clean-files += $(shell $(MAKE) -C $(TOPDIR)/arch/mips/tangox/fctrl/lib/fc clean)
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/prom.c linux-2.6.15/arch/mips/tangox/prom.c
--- linux-2.6.15.ref/arch/mips/tangox/prom.c	2008-02-11 19:16:14.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/prom.c	2008-02-11 19:17:40.000000000 -0800
@@ -231,6 +231,149 @@
 }
 #endif
 
+#ifdef CONFIG_TANGOX_FIXED_FREQUENCIES
+unsigned long tangox_get_dspclock(void)
+{
+	return(0);
+}
+#else
+unsigned long tangox_get_dspclock(void)
+{
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	unsigned long sys_clkgen_pll, sysclk_mux, sysclk_premux;
+	unsigned long n, m, freq, div, k, mux;
+
+	k = m = sys_clkgen_pll = 0;
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+	sysclk_premux = RD_BASE_REG32(SYS_sysclk_premux);
+
+	switch(sysclk_premux & 0x3) {
+		case 0:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen0_pll);
+			m = (sys_clkgen_pll >> 16) & 0x1f;
+			k = (sys_clkgen_pll >> 14) & 0x3;
+			break;
+		case 1:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen1_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+		case 2:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen2_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+		case 3:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen3_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+	}
+	n = sys_clkgen_pll & 0x000003ff;
+
+	/* Not using XTAL_IN, cannot calculate */
+	if ((sys_clkgen_pll & 0x07000000) != 0x01000000)
+		return(0);
+
+	/* Calculate the divider */
+	mux = (sysclk_mux >> 8) & 0xf;
+	if ((mux >= 2) && (mux <= 5)) /* Get DSP frequency */
+		div = 3;
+	else if ((mux == 1) || (mux == 8) || (mux == 9))
+		div = 4;
+	else if ((mux == 0) || (mux == 6) || (mux == 7) ||
+		 (mux == 0xa) || (mux == 0xb))
+		div = 2;
+	else
+		return(0); /* Wrong divider setting */
+
+	if (sysclk_mux & 0x1) 	/* PLL is used */
+		freq = ((TANGOX_BASE_FREQUENCY / (m + 2)) * (n + 2)) /
+			(div * (1 << k));
+	else
+		freq = TANGOX_BASE_FREQUENCY / div;
+#else
+	unsigned long sys_clkgen_pll, sysclk_mux, n, m, freq, div;
+
+	sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen_pll);
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+	n = sys_clkgen_pll & 0x000003ff;
+	m = (sys_clkgen_pll & 0x003f0000) >> 16;
+
+	/* Calculate the divider */
+	if ((sysclk_mux & 0x300) == 0x000) /* Get system clock frequency */
+		div = 2;
+	else if ((sysclk_mux & 0x300) == 0x100)
+		div = 4;
+	else
+		div = 3;
+
+	if (sysclk_mux & 0x1) 	/* PLL is used */
+		freq = ((TANGOX_BASE_FREQUENCY / (m + 2)) * (n + 2)) / div;
+	else
+		freq = TANGOX_BASE_FREQUENCY / div;
+#endif
+	return(freq);
+}
+#endif
+
+#ifdef CONFIG_TANGOX_FIXED_FREQUENCIES
+unsigned long tangox_get_pllclock(int pll)
+{
+	return(0);
+}
+#else
+unsigned long tangox_get_pllclock(int pll)
+{
+#if (defined(CONFIG_TANGO2) && (EM86XX_REVISION > 3)) || defined(CONFIG_TANGO3)
+	unsigned long sys_clkgen_pll, sysclk_mux;
+	unsigned long n, m, freq, k;
+
+	k = m = sys_clkgen_pll = 0;
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+
+	switch(pll) {
+		case 0:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen0_pll);
+			m = (sys_clkgen_pll >> 16) & 0x1f;
+			k = (sys_clkgen_pll >> 14) & 0x3;
+			break;
+		case 1:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen1_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+		case 2:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen2_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+		case 3:
+			sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen3_pll);
+			m = (sys_clkgen_pll >> 16) & 0x7f;
+			break;
+	}
+	n = sys_clkgen_pll & 0x000003ff;
+
+	/* Not using XTAL_IN, cannot calculate */
+	if ((sys_clkgen_pll & 0x07000000) != 0x01000000)
+		return(0);
+
+	if (sysclk_mux & 0x1) 	/* PLL is used */
+		freq = ((TANGOX_BASE_FREQUENCY / (m + 2)) * (n + 2)) / (1 << k);
+	else
+		freq = TANGOX_BASE_FREQUENCY;
+#else
+	unsigned long sys_clkgen_pll, sysclk_mux, n, m, freq;
+
+	sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen_pll);
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux);
+	n = sys_clkgen_pll & 0x000003ff;
+	m = (sys_clkgen_pll & 0x003f0000) >> 16;
+
+	if (sysclk_mux & 0x1) 	/* PLL is used */
+		freq = (TANGOX_BASE_FREQUENCY / (m + 2)) * (n + 2);
+	else
+		freq = TANGOX_BASE_FREQUENCY;
+#endif
+	return(freq);
+}
+#endif
 
 extern int do_syslog(int type, char * buf, int len);
 extern int __init xenv_config(void);
@@ -377,9 +520,10 @@
 		revStr = "unknown";
 	
 	printk("%s).\n", revStr);
-	printk("Detected CPU/SYS Frequencies: %ld.%02ld/%ld.%02ldMHz\n",
+	printk("Detected CPU/System/DSP Frequencies: %ld.%02ld/%ld.%02ld/%ld.%02ldMHz\n", 
 		tangox_get_cpuclock() / 1000000, (tangox_get_cpuclock() / 10000) % 100,
-		tangox_get_sysclock() / 1000000, (tangox_get_sysclock() / 10000) % 100);
+		tangox_get_sysclock() / 1000000, (tangox_get_sysclock() / 10000) % 100,
+		tangox_get_dspclock() / 1000000, (tangox_get_dspclock() / 10000) % 100);
 
 	/*
 	 * read xenv  configuration, we  need it quickly  to configure
@@ -529,6 +673,8 @@
 
 EXPORT_SYMBOL(tangox_get_sysclock);
 EXPORT_SYMBOL(tangox_get_cpuclock);
+EXPORT_SYMBOL(tangox_get_dspclock);
+EXPORT_SYMBOL(tangox_get_pllclock);
 
 unsigned long tangox_chip_id(void)
 {
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/setup.c linux-2.6.15/arch/mips/tangox/setup.c
--- linux-2.6.15.ref/arch/mips/tangox/setup.c	2008-02-11 19:16:16.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/setup.c	2008-02-11 19:17:40.000000000 -0800
@@ -247,6 +247,18 @@
 	gbus_writel(REG_BASE_cpu_block + CPU_time0_clr, 1);
 }
 
+#ifndef CONFIG_TANGOX_USE_CPU_CLOCK
+void reset_cpu_timer0(void)
+{
+	/* CPU_time0_load  register contains  just  16-bits value  So,
+	   take cate not the value to overflow */
+	WR_CPU_REG32(CPU_time0_load, TIMER_RELOAD);
+	WR_CPU_REG32(CPU_time0_ctrl, TIMER_ENABLE | TIMER_PERIODIC |
+			TIMER_PRESCALE_32);
+	WR_CPU_REG32(CPU_time0_clr, 1);
+}
+#endif
+
 /*
  * Setup Timer0 as the source
  */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/xenv_config.c linux-2.6.15/arch/mips/tangox/xenv_config.c
--- linux-2.6.15.ref/arch/mips/tangox/xenv_config.c	2008-02-11 19:16:14.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/xenv_config.c	2008-02-11 19:17:40.000000000 -0800
@@ -192,6 +192,12 @@
 static u8 mac_address1[6];
 #endif
 
+/* for power saving (e.g. low frequency) */
+static u32 ps_pll3=0, ps_pll2=0, ps_pll1=0, ps_pll0=0, ps_mux=0, ps_d0cfg=0, ps_d1cfg=0, ps_d0delay=0, ps_d1delay=0;
+
+/* for standby (e.g. sleep) */
+static u32 standby_pll3=0, standby_pll2=0, standby_pll1=0, standby_pll0=0, standby_mux=0, standby_d0cfg=0, standby_d1cfg=0, standby_d0delay=0, standby_d1delay=0;
+
 static char xenv_cmdline[CL_SIZE] = { 0 };
 
 #ifdef CONFIG_TANGOX_XENV_READ
@@ -270,6 +276,26 @@
 		memcpy(xenv_cmdline, data, datasize);
 		xenv_cmdline[datasize] = 0;
 	}
+
+	CHECK_AND_STORE(XENV_KEY_PS_PLL3, 4, ps_pll3);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL2, 4, ps_pll2);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL1, 4, ps_pll1);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL0, 4, ps_pll0);
+	CHECK_AND_STORE(XENV_KEY_PS_MUX, 4, ps_mux);
+	CHECK_AND_STORE(XENV_KEY_PS_D0CFG, 4, ps_d0cfg);
+	CHECK_AND_STORE(XENV_KEY_PS_D1CFG, 4, ps_d1cfg);
+	CHECK_AND_STORE(XENV_KEY_PS_D0DELAY, 4, ps_d0delay);
+	CHECK_AND_STORE(XENV_KEY_PS_D1DELAY, 4, ps_d1delay);
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL3, 4, standby_pll3);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL2, 4, standby_pll2);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL1, 4, standby_pll1);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL0, 4, standby_pll0);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_MUX, 4, standby_mux);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D0CFG, 4, standby_d0cfg);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D1CFG, 4, standby_d1cfg);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D0DELAY, 4, standby_d0delay);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D1DELAY, 4, standby_d1delay);
 }
 
 /*
@@ -645,6 +671,34 @@
 	printk("\n");
 }
 
+void tangox_get_ps_config(u32 *pll3, u32 *pll2, u32 *pll1, u32 *pll0, u32 *mux, u32 *d0cfg, u32 *d0delay, u32 *d1cfg, u32 *d1delay)
+{
+	*pll3 = ps_pll3;
+	*pll2 = ps_pll2;
+	*pll1 = ps_pll1;
+	*pll0 = ps_pll0;
+	*mux = ps_mux;
+	*d0cfg = ps_d0cfg;
+	*d1cfg = ps_d1cfg;
+	*d0delay = ps_d0delay;
+	*d1delay = ps_d1delay;
+}
+
+void tangox_get_standby_config(u32 *pll3, u32 *pll2, u32 *pll1, u32 *pll0, u32 *mux, u32 *d0cfg, u32 *d0delay, u32 *d1cfg, u32 *d1delay)
+{
+	*pll3 = standby_pll3;
+	*pll2 = standby_pll2;
+	*pll1 = standby_pll1;
+	*pll0 = standby_pll0;
+	*mux = standby_mux;
+	*d0cfg = standby_d0cfg;
+	*d1cfg = standby_d1cfg;
+	*d0delay = standby_d0delay;
+	*d1delay = standby_d1delay;
+}
+
 EXPORT_SYMBOL(tangox_ethernet_getmac);
 EXPORT_SYMBOL(tangox_get_scard_info);
+EXPORT_SYMBOL(tangox_get_ps_config);
+EXPORT_SYMBOL(tangox_get_standby_config);
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/tangox/xenvkeys.h linux-2.6.15/arch/mips/tangox/xenvkeys.h
--- linux-2.6.15.ref/arch/mips/tangox/xenvkeys.h	2008-02-11 19:16:14.000000000 -0800
+++ linux-2.6.15/arch/mips/tangox/xenvkeys.h	2008-02-11 19:17:40.000000000 -0800
@@ -114,6 +114,26 @@
 #define XENV_KEYS_CS_PART_SIZE      "l.cs%d_part%d_size"
 #define XENV_KEYS_CS_PART_OFFSET    "l.cs%d_part%d_offset" 
 
+#define XENV_KEY_PS_PLL3            "a.ps.pll3"
+#define XENV_KEY_PS_PLL2            "a.ps.pll2"
+#define XENV_KEY_PS_PLL1            "a.ps.pll1"
+#define XENV_KEY_PS_PLL0            "a.ps.pll0"
+#define XENV_KEY_PS_MUX             "a.ps.mux"
+#define XENV_KEY_PS_D0CFG           "a.ps.d0cfg"
+#define XENV_KEY_PS_D1CFG           "a.ps.d1cfg"
+#define XENV_KEY_PS_D0DELAY         "a.ps.d0delay"
+#define XENV_KEY_PS_D1DELAY         "a.ps.d1delay"
+
+#define XENV_KEY_STANDBY_PLL3       "a.standby.pll3"
+#define XENV_KEY_STANDBY_PLL2       "a.standby.pll2"
+#define XENV_KEY_STANDBY_PLL1       "a.standby.pll1"
+#define XENV_KEY_STANDBY_PLL0       "a.standby.pll0"
+#define XENV_KEY_STANDBY_MUX        "a.standby.mux"
+#define XENV_KEY_STANDBY_D0CFG      "a.standby.d0cfg"
+#define XENV_KEY_STANDBY_D1CFG      "a.standby.d1cfg"
+#define XENV_KEY_STANDBY_D0DELAY    "a.standby.d0delay"
+#define XENV_KEY_STANDBY_D1DELAY    "a.standby.d1delay"
+
 #ifndef CONFIG_SIGBLOCK_SUPPORT
 #define ISAIDE_SHIFT		0
 #define BMIDE_SHIFT		1
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/tangox-bmide.c linux-2.6.15/drivers/ide/tangox/tangox-bmide.c
--- linux-2.6.15.ref/drivers/ide/tangox/tangox-bmide.c	2008-02-11 19:16:25.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/tangox-bmide.c	2008-02-11 19:17:40.000000000 -0800
@@ -546,6 +546,8 @@
 /*
  * tangox_bmide_tune_chipset
  */
+static u8 drive_speed[2] = { 0xff, 0xff };
+
 static int tangox_bmide_tune_chipset(ide_drive_t *drive, u8 xferspeed)
 {
 	int didx;
@@ -674,6 +676,7 @@
 #endif
 		pio = xferspeed - XFER_PIO_0;
 
+	drive_speed[didx] = xferspeed;
 	return ide_config_drive_speed(drive, xferspeed);
 }
 
@@ -701,9 +704,103 @@
  */
 extern int tangox_bmide_enabled(void);
 
+/* to calcuate the speed needed */
+void tangox_bmide_calc_speed(void)
+{
+	int didx;
+	u8 xferspeed;
+	u8 mode;
+	unsigned long flags;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+	extern unsigned long tangox_get_sysclock(void);
+	unsigned int ide_clock = TIMING_MARGIN(tangox_get_sysclock() / 1000000); /* in MHz */
+#endif
+	
+	if (!tangox_bmide_enabled())
+		return;
+	
+	spin_lock_irqsave(&bmide_tune_chipset_spin_lock, flags);
+	
+	for (didx = 0; didx < 2; didx++) {
+		if ((xferspeed = drive_speed[didx]) == 0xff)
+			continue;
+		
+		if (xferspeed >= XFER_PIO_0 && xferspeed <= XFER_PIO_4) {
+			/*
+			 * setup timing for PIO mode
+			 */
+			mode = xferspeed - XFER_PIO_0;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim),
+					CalcRegValTiming_PIO_DMA(&(j2_pio_timings[mode]), ide_clock));
+#else
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim),
+					s_pio_tim[mode]);
+#endif
+		}
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+		else if (xferspeed >= XFER_MW_DMA_0 && xferspeed <= XFER_MW_DMA_2) {
+			/*
+			 * setup timing for Multi-word DMA
+			 */
+			mode = xferspeed - XFER_MW_DMA_0;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim),
+					CalcRegValTiming_PIO_DMA(&(j2_dma_timings[mode]), ide_clock));
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1),
+					
+					CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2),
+					CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0tim : IDECTRL_pri_drv1tim),
+					s_dma_tim[mode]);
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1),
+					s_udma_tim1[mode]);
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2),
+					s_udma_tim2[mode]);
+#endif
+		}
+#endif
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_UDMA
+		else if (xferspeed >= XFER_UDMA_0 && xferspeed <= XFER_UDMA_7) {
+			/*
+			 * setup timing for Ultra DMA
+			 */
+			mode = xferspeed - XFER_UDMA_0;
+#ifdef CONFIG_RUNTIME_CLK_CALC
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1),
+					CalcRegValTiming1_UDMA(&(j2_udma_timings[mode]), ide_clock));
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2),
+					CalcRegValTiming2_UDMA(&(j2_udma_timings[mode]), ide_clock));
+#else
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim1 : IDECTRL_pri_drv1udmatim1),
+					s_udma_tim1_alt[mode]);
+			gbus_writel(REG_BASE_host_interface +
+					((didx == 0) ? IDECTRL_pri_drv0udmatim2 : IDECTRL_pri_drv1udmatim2),
+					s_udma_tim2_alt[mode]);
+#endif
+		}
+#endif
+	}
+
+	spin_unlock_irqrestore(&bmide_tune_chipset_spin_lock, flags);
+}
+
 int __init tangox_bmide_init(void)
 {
-        ide_hwif_t *hwif;
+	ide_hwif_t *hwif;
 	hw_regs_t hw;
 	int index;
 	if (!tangox_bmide_enabled()) {
@@ -934,3 +1031,5 @@
 }
 #endif /* CONFIG_RUNTIME_CLK_CALC */
 
+EXPORT_SYMBOL(tangox_bmide_calc_speed);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/tangox-pbide.c linux-2.6.15/drivers/ide/tangox/tangox-pbide.c
--- linux-2.6.15.ref/drivers/ide/tangox/tangox-pbide.c	2008-02-11 19:16:25.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/tangox-pbide.c	2008-02-11 19:17:40.000000000 -0800
@@ -413,6 +413,8 @@
 	return tangox_ide_config_drive_for_dma(drive, 0);
 }
 
+static u8 drive_speed[2] = { 0xff, 0xff };
+
 static void tangox_pbide_tune_chipset_drive(int drive, int speed, int verbose)
 {
 	extern unsigned long tangox_get_sysclock(void);
@@ -426,6 +428,8 @@
 	else
 		return;	
 
+	drive_speed[drive] = speed;
+
 	// get_pb_ide_timing() receives mode in reversed order
 	//   PIO : 7-3
 	//   Multi-word DMA : 2-0
@@ -468,6 +472,40 @@
 }
 #endif
 
+/* to calcuate the speed needed */
+void tangox_pbide_calc_speed(void)
+{
+	int didx;
+	int mode, speed;
+	unsigned int timing;
+	// u8 xferspeed;
+	extern unsigned long tangox_get_sysclock(void);
+	
+	if (tangox_isaide_enabled() == 0)
+		return;
+	
+	for (didx = 0; didx < 2; didx++) {
+		if ((speed = drive_speed[didx]) == 0xff)
+			continue;
+		
+		mode = speed & 0x0f;
+		
+		if (speed >= XFER_PIO_0 && speed <= XFER_PIO_4)
+			mode -= 8;
+		else if (speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2)
+			mode += 5;
+		else
+			continue;
+		
+		// get_pb_ide_timing() receives mode in reversed order
+		//   PIO : 7-3
+		//   Multi-word DMA : 2-0
+		mode = 7 - mode;
+		timing = get_pb_ide_timing(tangox_get_sysclock() * 11 / (10*1000000), mode);
+		gbus_writel(REG_BASE_host_interface + PB_timing_slot(tangox_isaide_timing_slot()), timing);
+	}
+}
+
 //
 // initialize IDE driver
 //
@@ -546,3 +584,5 @@
 module_exit(tangox_pbide_exit);
 #endif
 
+EXPORT_SYMBOL(tangox_pbide_calc_speed);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/include/asm-mips/addrspace.h linux-2.6.15/include/asm-mips/addrspace.h
--- linux-2.6.15.ref/include/asm-mips/addrspace.h	2006-01-25 20:51:58.000000000 -0800
+++ linux-2.6.15/include/asm-mips/addrspace.h	2008-02-11 19:17:40.000000000 -0800
@@ -11,7 +11,7 @@
 #define _ASM_ADDRSPACE_H
 
 #include <linux/config.h>
-#include <spaces.h>
+/* #include <spaces.h> -- not used */
 
 /*
  *  Configure language
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/README.1013.frequency.patch linux-2.6.15/README.1013.frequency.patch
--- linux-2.6.15.ref/README.1013.frequency.patch	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/README.1013.frequency.patch	2008-02-11 19:18:22.000000000 -0800
@@ -0,0 +1,24 @@
+Feature:
+--------
+Changing frequencies is allowed while syncing up the timer.
+Runtime frequency control via procfs interface.
+(Optionally) standy mode support -- experimental.
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+1001
+1004
+1010
+
+Primary author:
+---------------
+YH Lin
+
+Related to which chip version SMP86xx xx=?
+-----------------------------------------
+all
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
